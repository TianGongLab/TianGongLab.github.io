<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>以 CVE-2024-26229 为例分析 Windows RDBSS 机制 | 天工实验室</title>
<meta name="keywords" content="Windows, CVE-2024-26229, Client Side Caching, CSC, Redirected Drive Buffering SubSystem, RDBSS">
<meta name="description" content="以 CVE-2024-26229 为例分析 Windows RDBSS 机制 一、前言 CVE-2024-26229是今年4月微软修补的一个任意地址写零漏洞，该漏洞位于csc.sys驱动中。攻击者在Windows上获得较低权限的任意代码执行后，可以利用该漏洞将低权限提升至system权限。目前Exp由varwara公布在了github上。
二、csc.sys简介 csc.sys(Windows Client Side Caching Driver)是脱机文件(offline files)功能的一部分。脱机文件功能是默认在本机存一份共享文件的副本，这样做的优点有两点，一方面可以节省网络流量，另一方面是断网条件下，仍然可以使用共享文件夹，等到有网之后再进行同步。默认副本文件存储在C:\Windows\CSC文件夹中，普通用户没有权限访问该文件夹的内容。
下面以SMB协议为例，演示如何开启脱机文件功能。
首先准备两台虚拟机，一台为SMB server，一台为SMB client。
在SMB Server首先新建一个文件夹，然后共享此文件夹，并设置此权限为完全控制。
在SMB client打开控制面板进入同步中心-&gt;管理脱机文件-&gt;启动脱机文件。
然后访问SMB server，点击始终脱机可用。
之后就会出现一个新的文件夹，即为本机副本。
此时关闭share文件夹分享，仍然能操作share文件夹。
三、漏洞成因分析 通过README可以看出该漏洞产生的原因是在csc.sys中没有校验用户态以METHOD_NEITHER方式和驱动进行通信时用户态传入的缓冲区地址是否是合法地址，从而导致任意地址读或者任意地址写。
下面介绍一下windows用户态与驱动的通信方式来解释为什么以METHOD_NEITHER与驱动进行通信时需要对用户态传入的地址进行合法校验。
在windows中用户态与驱动的通信方式共有三种:
METHOD_BUFFERED METHOD_IN_DIRECT METHOD_OUT_DIRECT METHOD_NEITHER METHOD_BUFFERED方式对UserInputBuffer和UserOutputBuffer都进行缓冲，驱动程序无需对用户态传入的缓冲区地址进行校验。
METHOD_IN_DIRECT和METHOD_OUT_DIRECT只对UserInputBuffer进行缓冲，对于UserOutputBuffer采用的是将用户态地址锁定(即不让其换出内存)，然后映射为内核地址。在驱动写入后，重新映射为用户态地址。
METHOD_NEITHER (也就是出现漏洞的这种通信方式) 驱动程序直接读写用户态的缓冲区，优点是读写更快，缺点是驱动程序在读写缓冲区之前需要使用ProbeForRead/ProbeForWrite函数去探测地址是否合法。就可能会出现漏洞，例如用户态的传入的UserInputBuffer和UserOutputBuffer均为内核态地址，驱动就会根据用户态传入地址读写，即可造成任意地址读写。
四、补丁分析 可以看到有两个函数有改动，既然本漏洞是关于I/O control的，那么优先看CscDevFcbXXXControlFile这个函数改动。
通过bindiff可以看到从00000001C006B243这个块开始有所不同，定位到对应的反编译的伪c代码进行比较。
在patch之后的代码加了一个if判断
如果if 判断条件为true，则首先在使用前判断v12是否小于0x24 如果小于0x24，则调用失败
如果大于等于0x24，则会判断(a1&#43;40)&#43;64的是否不为0，这里推测如果为1的话，应该表示该请求来自用户态
如果不为0，则会使用ProbeForWrite探测a1&#43;536的地址是否合法 然后对a1&#43;536的位置写入一个8字节的0 (这里可能就是未patch的漏洞点了)
如果if判断条件为false，则使用原来的漏洞代码 patch代码保留原来漏洞代码目的推测为微软可能认为新代码可能会影响正常的功能，一旦遇到问题可以只需要改一下某个标志位就可以回滚回原来的代码，等到新代码完全稳定后估计就会删除原来的漏洞代码。
五、漏洞触发流程分析 从目前的分析来看，这个漏洞模式比较简单，为什么之前没有被人扫描到或者分析出来，我认为有两点原因。
ida反编译显示错误，有的时候你看csc.sys驱动的DriverEntry函数,可能如下图所示： 如果你多次Undefine然后重新反编译DriverEntry，就会发现DriverEntry函数是很长的。
csc.sys是一个内核网络微型重定向器驱动程序(Kernel Network Mini-Redirector Driver)使用了重定向驱动器缓冲子系统 (Redirected Drive Buffering Subsystem) 使得处理DeviceIoControl调用栈过深，不易被发现。 由DriverEntry可以看到用户态所有请求都由CscFsdDispatch处理，跟进CscFsdDispatch函数可以发现大部分的请求都是由导入函数RxFsdDispatch处理
RxFsdDispatch是由rdbss.sys中实现，下面介绍以下csc.sys与rdbss.sys交互为例介绍rdbss机制。
5.1 rdbss机制分析 csc.">
<meta name="author" content="wanghaozhe">
<link rel="canonical" href="http://localhost:1313/blog/tiangongarticle037/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9b0c42f9222bc665b5845e6199fc07fd87b025125d3366cc5f873b0f54ca8481.css" integrity="sha256-mwxC&#43;SIrxmW1hF5hmfwH/YewJRJdM2bMX4c7D1TKhIE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/blog/tiangongarticle037/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="天工实验室 (Alt + H)">
                <img src="http://localhost:1313/logo/logo3.png" alt="" aria-label="logo"
                    height="100" style="margin-top: 15px;">
            </a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://poc.qianxin.com/home" title="破壳官网">
                    <span>破壳官网</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blog/">博客</a></div>
    <h1 class="post-title entry-hint-parent">
      以 CVE-2024-26229 为例分析 Windows RDBSS 机制
    </h1>
    <div class="post-meta">5 分钟&nbsp;·&nbsp;wanghaozhe

</div>
  </header>

  <div class="author">
    <div class="author_avatar">
      <img src="/authors/pwnht.jpg" alt="wanghaozhe">
    </div>
    <div class="author_info">
      <span class="author_id">wanghaozhe</span>
      <p class="author_description">天工实验室安全研究员，主攻利用二进制静态分析方法挖掘漏洞</p>
    </div>
  </div>
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/windows/">Windows</a></li>
      <li><a href="http://localhost:1313/tags/cve-2024-26229/">CVE-2024-26229</a></li>
      <li><a href="http://localhost:1313/tags/client-side-caching/">Client Side Caching</a></li>
      <li><a href="http://localhost:1313/tags/csc/">CSC</a></li>
      <li><a href="http://localhost:1313/tags/redirected-drive-buffering-subsystem/">Redirected Drive Buffering SubSystem</a></li>
      <li><a href="http://localhost:1313/tags/rdbss/">RDBSS</a></li>
    </ul><br/> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%bb%a5-cve-2024-26229-%e4%b8%ba%e4%be%8b%e5%88%86%e6%9e%90-windows-rdbss-%e6%9c%ba%e5%88%b6" aria-label="以 CVE-2024-26229 为例分析 Windows RDBSS 机制">以 CVE-2024-26229 为例分析 Windows RDBSS 机制</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%89%8d%e8%a8%80" aria-label="一、前言">一、前言</a></li>
                <li>
                    <a href="#%e4%ba%8ccscsys%e7%ae%80%e4%bb%8b" aria-label="二、csc.sys简介">二、csc.sys简介</a></li>
                <li>
                    <a href="#%e4%b8%89%e6%bc%8f%e6%b4%9e%e6%88%90%e5%9b%a0%e5%88%86%e6%9e%90" aria-label="三、漏洞成因分析">三、漏洞成因分析</a></li>
                <li>
                    <a href="#%e5%9b%9b%e8%a1%a5%e4%b8%81%e5%88%86%e6%9e%90" aria-label="四、补丁分析">四、补丁分析</a></li>
                <li>
                    <a href="#%e4%ba%94%e6%bc%8f%e6%b4%9e%e8%a7%a6%e5%8f%91%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90" aria-label="五、漏洞触发流程分析">五、漏洞触发流程分析</a><ul>
                        
                <li>
                    <a href="#51-rdbss%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90" aria-label="5.1 rdbss机制分析">5.1 rdbss机制分析</a><ul>
                        
                <li>
                    <a href="#511-cscsys%e5%9c%a8%e5%88%9d%e5%a7%8b%e5%8c%96%e6%97%b6%e8%b0%83%e7%94%a8rxregisterminirdr%e5%88%9d%e5%a7%8b%e5%8c%96prdbss_device_object%e7%9a%84%e9%83%a8%e5%88%86%e6%88%90%e5%91%98" aria-label="5.1.1 csc.sys在初始化时调用RxRegisterMinirdr()初始化PRDBSS_DEVICE_OBJECT的部分成员">5.1.1 csc.sys在初始化时调用RxRegisterMinirdr()初始化PRDBSS_DEVICE_OBJECT的部分成员</a></li>
                <li>
                    <a href="#512-%e7%94%a8%e6%88%b7%e6%80%81%e8%bf%9b%e7%a8%8b%e6%89%93%e5%bc%80cscsys%e9%a9%b1%e5%8a%a8%e8%ae%be%e5%a4%87%e7%9a%84%e7%ac%a6%e5%8f%b7%e9%93%be%e6%8e%a5%e6%88%96%e8%80%85%e5%88%9b%e5%bb%ba%e8%84%b1%e6%9c%ba%e6%96%87%e4%bb%b6%e6%96%87%e4%bb%b6%e5%a4%b9%e7%9a%84%e6%93%8d%e4%bd%9c" aria-label="5.1.2 用户态进程打开csc.sys驱动设备的符号链接或者创建脱机文件、文件夹的操作">5.1.2 用户态进程打开csc.sys驱动设备的符号链接或者创建脱机文件、文件夹的操作</a></li>
                <li>
                    <a href="#513-%e7%94%a8%e6%88%b7%e6%80%81%e8%bf%9b%e7%a8%8b%e5%af%b9%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6%e8%bf%9b%e7%a8%8b%e6%93%8d%e4%bd%9c%e4%be%8b%e5%a6%82deviceiocontrol%e8%af%bb%e5%86%99%e7%ad%89" aria-label="5.1.3 用户态进程对打开的文件进程操作，例如DeviceIoControl、读写等">5.1.3 用户态进程对打开的文件进程操作，例如DeviceIoControl、读写等</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%94exp%e5%88%86%e6%9e%90" aria-label="五、Exp分析">五、Exp分析</a></li>
                <li>
                    <a href="#%e5%85%ad%e6%80%bb%e7%bb%93" aria-label="六、总结">六、总结</a></li>
                <li>
                    <a href="#%e4%b8%83%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" aria-label="七、参考链接">七、参考链接</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="以-cve-2024-26229-为例分析-windows-rdbss-机制">以 CVE-2024-26229 为例分析 Windows RDBSS 机制<a hidden class="anchor" aria-hidden="true" href="#以-cve-2024-26229-为例分析-windows-rdbss-机制">#</a></h1>
<h2 id="一前言">一、前言<a hidden class="anchor" aria-hidden="true" href="#一前言">#</a></h2>
<p>CVE-2024-26229是今年4月微软修补的一个任意地址写零漏洞，该漏洞位于csc.sys驱动中。攻击者在Windows上获得较低权限的任意代码执行后，可以利用该漏洞将低权限提升至system权限。目前Exp由varwara公布在了<a href="https://github.com/varwara/CVE-2024-26229/">github</a>上。</p>
<!-- raw HTML omitted -->
<h2 id="二cscsys简介">二、csc.sys简介<a hidden class="anchor" aria-hidden="true" href="#二cscsys简介">#</a></h2>
<p>csc.sys(Windows Client Side Caching Driver)是脱机文件(offline files)功能的一部分。脱机文件功能是默认在本机存一份共享文件的副本，这样做的优点有两点，一方面可以节省网络流量，另一方面是断网条件下，仍然可以使用共享文件夹，等到有网之后再进行同步。默认副本文件存储在C:\Windows\CSC文件夹中，普通用户没有权限访问该文件夹的内容。</p>
<p>下面以SMB协议为例，演示如何开启脱机文件功能。</p>
<p>首先准备两台虚拟机，一台为SMB server，一台为SMB client。</p>
<p>在SMB Server首先新建一个文件夹，然后共享此文件夹，并设置此权限为完全控制。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//ce98315f-d518-4ac3-b765-bdca7ecc121b.png" alt=""  />
</p>
<p>在SMB client打开控制面板进入同步中心-&gt;管理脱机文件-&gt;启动脱机文件。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//5da530ce-540d-43de-b837-f1a5db091da9.png" alt=""  />
</p>
<p>然后访问SMB server，点击始终脱机可用。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//f9893d84-8e81-4739-beaf-0a99468baa8d.png" alt=""  />
</p>
<p>之后就会出现一个新的文件夹，即为本机副本。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//c4ff2e0e-dd04-48d1-a2d7-ea633109f97d.png" alt=""  />
</p>
<p>此时关闭share文件夹分享，仍然能操作share文件夹。</p>
<h2 id="三漏洞成因分析">三、漏洞成因分析<a hidden class="anchor" aria-hidden="true" href="#三漏洞成因分析">#</a></h2>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//1a844d32-8bb7-4041-aff5-2417ea3b3b9d.png" alt=""  />
</p>
<p>通过README可以看出该漏洞产生的原因是在csc.sys中没有校验用户态以METHOD_NEITHER方式和驱动进行通信时用户态传入的缓冲区地址是否是合法地址，从而导致任意地址读或者任意地址写。</p>
<p>下面介绍一下windows用户态与驱动的通信方式来解释为什么以METHOD_NEITHER与驱动进行通信时需要对用户态传入的地址进行合法校验。</p>
<p>在windows中用户态与驱动的通信方式共有三种:</p>
<ul>
<li>METHOD_BUFFERED</li>
<li>METHOD_IN_DIRECT</li>
<li>METHOD_OUT_DIRECT</li>
<li>METHOD_NEITHER</li>
</ul>
<p>METHOD_BUFFERED方式对UserInputBuffer和UserOutputBuffer都进行缓冲，驱动程序无需对用户态传入的缓冲区地址进行校验。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//165b8a20-35e8-4f33-8a6f-2cef92200bd8.png" alt=""  />
</p>
<p>METHOD_IN_DIRECT和METHOD_OUT_DIRECT只对UserInputBuffer进行缓冲，对于UserOutputBuffer采用的是将用户态地址锁定(即不让其换出内存)，然后映射为内核地址。在驱动写入后，重新映射为用户态地址。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//2c728c20-f5c8-4dbf-8504-9344366254a4.png" alt=""  />
</p>
<p>METHOD_NEITHER (也就是出现漏洞的这种通信方式) 驱动程序直接读写用户态的缓冲区，优点是读写更快，缺点是驱动程序在读写缓冲区之前需要使用ProbeForRead/ProbeForWrite函数去探测地址是否合法。就可能会出现漏洞，例如用户态的传入的UserInputBuffer和UserOutputBuffer均为内核态地址，驱动就会根据用户态传入地址读写，即可造成任意地址读写。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//99668516-3595-44e1-ae92-b39cad697ec4.png" alt=""  />
</p>
<h2 id="四补丁分析">四、补丁分析<a hidden class="anchor" aria-hidden="true" href="#四补丁分析">#</a></h2>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//15374c29-2287-443a-bcb5-931a00d08b47.png" alt=""  />
</p>
<p>可以看到有两个函数有改动，既然本漏洞是关于I/O control的，那么优先看CscDevFcbXXXControlFile这个函数改动。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//9fa74bde-76ef-4049-b61b-b447f95fefc2.png" alt=""  />
</p>
<p>通过bindiff可以看到从00000001C006B243这个块开始有所不同，定位到对应的反编译的伪c代码进行比较。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//8619bfbc-65e2-4a2b-91ba-d21241f4afb2.png" alt=""  />
</p>
<p>在patch之后的代码加了一个if判断</p>
<ul>
<li>如果if 判断条件为true，则首先在使用前判断v12是否小于0x24
<ul>
<li>
<p>如果小于0x24，则调用失败</p>
</li>
<li>
<p>如果大于等于0x24，则会判断(a1+40)+64的是否不为0，这里推测如果为1的话，应该表示该请求来自用户态</p>
<ul>
<li>如果不为0，则会使用ProbeForWrite探测a1+536的地址是否合法</li>
</ul>
<p>然后对a1+536的位置写入一个8字节的0 (这里可能就是未patch的漏洞点了)</p>
</li>
</ul>
</li>
<li>如果if判断条件为false，则使用原来的漏洞代码</li>
</ul>
<p>patch代码保留原来漏洞代码目的推测为微软可能认为新代码可能会影响正常的功能，一旦遇到问题可以只需要改一下某个标志位就可以回滚回原来的代码，等到新代码完全稳定后估计就会删除原来的漏洞代码。</p>
<h2 id="五漏洞触发流程分析">五、漏洞触发流程分析<a hidden class="anchor" aria-hidden="true" href="#五漏洞触发流程分析">#</a></h2>
<p>从目前的分析来看，这个漏洞模式比较简单，为什么之前没有被人扫描到或者分析出来，我认为有两点原因。</p>
<ul>
<li>ida反编译显示错误，有的时候你看csc.sys驱动的DriverEntry函数,可能如下图所示：</li>
</ul>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//019264d3-331d-4905-81e0-b9226be2ea33.png" alt=""  />
</p>
<p>如果你多次Undefine然后重新反编译DriverEntry，就会发现DriverEntry函数是很长的。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//4e292d76-90b5-46c8-8569-cc1bcd09ce3f.png" alt=""  />
</p>
<ul>
<li>csc.sys是一个内核网络微型重定向器驱动程序(Kernel Network Mini-Redirector Driver)使用了重定向驱动器缓冲子系统 (Redirected Drive Buffering Subsystem) 使得处理DeviceIoControl调用栈过深，不易被发现。</li>
</ul>
<p>由DriverEntry可以看到用户态所有请求都由CscFsdDispatch处理，跟进CscFsdDispatch函数可以发现大部分的请求都是由导入函数RxFsdDispatch处理</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//57d57aa4-d469-43cd-b3b6-85a9857a6018.png" alt=""  />
</p>
<p>RxFsdDispatch是由rdbss.sys中实现，下面介绍以下csc.sys与rdbss.sys交互为例介绍rdbss机制。</p>
<h3 id="51-rdbss机制分析">5.1 rdbss机制分析<a hidden class="anchor" aria-hidden="true" href="#51-rdbss机制分析">#</a></h3>
<p>csc.sys与rdbss.sys的交互分为三个状态，并且是顺序的。</p>
<h4 id="511-cscsys在初始化时调用rxregisterminirdr初始化prdbss_device_object的部分成员">5.1.1 csc.sys在初始化时调用RxRegisterMinirdr()初始化PRDBSS_DEVICE_OBJECT的部分成员<a hidden class="anchor" aria-hidden="true" href="#511-cscsys在初始化时调用rxregisterminirdr初始化prdbss_device_object的部分成员">#</a></h4>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//2191713f-65ec-4175-ab07-63795142c376.png" alt=""  />
</p>
<p>RxRegisterMinirdr函数声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">RxRegisterMinirdr</span>(
</span></span><span style="display:flex;"><span>  [out]     OUT PRDBSS_DEVICE_OBJECT <span style="color:#f92672">*</span>DeviceObject,
</span></span><span style="display:flex;"><span>  [in, out] IN OUT PDRIVER_OBJECT    DriverObject,
</span></span><span style="display:flex;"><span>  [in]      IN PMINIRDR_DISPATCH     MrdrDispatch,
</span></span><span style="display:flex;"><span>  [in]      IN ULONG                 Controls,
</span></span><span style="display:flex;"><span>  [in]      IN PUNICODE_STRING       DeviceName,
</span></span><span style="display:flex;"><span>  [in]      IN ULONG                 DeviceExtensionSize,
</span></span><span style="display:flex;"><span>  [in]      IN DEVICE_TYPE           DeviceType,
</span></span><span style="display:flex;"><span>  [in]      IN ULONG                 DeviceCharacteristics
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>这里主要关注MrdrDispatch这个参数，这个参数指向网络微型重定向驱动的调度表的指针。此调度表包括网络微型重定向驱动的配置信息和指向由网络微型重定向器内核驱动程序实现的回调例程的指针表。RDBSS 通过此回调例程列表调用网络微型重定向器驱动程序。</p>
<p>在csc.sys由CscInitializeDispatchTable()初始化此表。可以看到漏洞函数也在此表中。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//bfa6e61b-b0e7-42b6-8807-7222df50901a.png" alt=""  />
</p>
<p>在RxRegisterMinirdr具体实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>NTSTATUS <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">RxRegisterMinirdr</span>(
</span></span><span style="display:flex;"><span>        PRDBSS_DEVICE_OBJECT <span style="color:#f92672">*</span>PRdbssDeviceObject,
</span></span><span style="display:flex;"><span>        PDRIVER_OBJECT DriverObject,
</span></span><span style="display:flex;"><span>        _NEW_MINIRDR_DISPATCH <span style="color:#f92672">*</span>MrdrDispatch,
</span></span><span style="display:flex;"><span>        ULONG Controls,
</span></span><span style="display:flex;"><span>        PUNICODE_STRING DeviceName,
</span></span><span style="display:flex;"><span>        ULONG DeviceExtensionSize,
</span></span><span style="display:flex;"><span>        ULONG DeviceType,
</span></span><span style="display:flex;"><span>        ULONG DeviceCharacteristics)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v38 <span style="color:#f92672">=</span> PRdbssDeviceObject;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ......
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 创建新的device object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  result <span style="color:#f92672">=</span> <span style="color:#a6e22e">IoCreateDevice</span>(
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">*</span>(PDRIVER_OBJECT <span style="color:#f92672">*</span>)DriverObjecta,
</span></span><span style="display:flex;"><span>             v16 <span style="color:#f92672">+</span> v19,
</span></span><span style="display:flex;"><span>             v20,
</span></span><span style="display:flex;"><span>             DeviceType,
</span></span><span style="display:flex;"><span>             DeviceCharacteristics,
</span></span><span style="display:flex;"><span>             <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">&amp;</span>v);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .....
</span></span><span style="display:flex;"><span>  v21 <span style="color:#f92672">=</span> v38;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .....
</span></span><span style="display:flex;"><span>  v22 <span style="color:#f92672">=</span> DeviceObject;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 初始化PRdbssDeviceObject的DeviceObject成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>v21 <span style="color:#f92672">=</span> DeviceObject;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 将调度表放到新的device object 偏移0x160处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  v22<span style="color:#f92672">-&gt;</span>MrdrDispatch <span style="color:#f92672">=</span> (<span style="color:#66d9ef">__int64</span>)MrdrDispatch;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 初始化DeviceObject其他成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DeviceObject<span style="color:#f92672">-&gt;</span>Controls <span style="color:#f92672">=</span> Controls;
</span></span><span style="display:flex;"><span>  DeviceObject<span style="color:#f92672">-&gt;</span>DeviceName <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>DeviceName;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">LOBYTE</span>(DeviceObject<span style="color:#f92672">-&gt;</span>field_180) <span style="color:#f92672">=</span> (Controls <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">BYTE1</span>(DeviceObject<span style="color:#f92672">-&gt;</span>field_180) <span style="color:#f92672">=</span> (Controls <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DeviceObject<span style="color:#f92672">-&gt;</span>DeviceName.MaximumLength <span style="color:#f92672">=</span> DeviceName<span style="color:#f92672">-&gt;</span>MaximumLength;
</span></span><span style="display:flex;"><span>  DeviceObject<span style="color:#f92672">-&gt;</span>DeviceName.Length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DeviceObject<span style="color:#f92672">-&gt;</span>DeviceName.Buffer <span style="color:#f92672">=</span> (<span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>DeviceObject[<span style="color:#ae81ff">1</span>].Controls <span style="color:#f92672">+</span> v16 <span style="color:#f92672">+</span> v37);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">RtlCopyUnicodeString</span>(<span style="color:#f92672">&amp;</span>DeviceObject<span style="color:#f92672">-&gt;</span>DeviceName, DeviceName);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .....
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过上面代码分析实际上CSC_DISPATCH_TABLE最终放在了CscDeviceObject中，在后面的RxFsdDispatch函数处理就可以通过CscDeviceObject索引到CSC_DISPATCH_TABLE从而进行调用。</p>
<h4 id="512-用户态进程打开cscsys驱动设备的符号链接或者创建脱机文件文件夹的操作">5.1.2 用户态进程打开csc.sys驱动设备的符号链接或者创建脱机文件、文件夹的操作<a hidden class="anchor" aria-hidden="true" href="#512-用户态进程打开cscsys驱动设备的符号链接或者创建脱机文件文件夹的操作">#</a></h4>
<p>当用户态进程进行此操作时，会向csc.sys发起IRP_MJ_CREATE请求。此IRP请求首先由csc.sys驱动中CscFsdDispatch()处理。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">CscFsdDispatch</span>(PDEVICE_OBJECT a1, IRP <span style="color:#f92672">*</span>a2, LARGE_INTEGER a3, <span style="color:#66d9ef">struct</span> _RDBSS_DEVICE_OBJECT <span style="color:#f92672">*</span>a4)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  CurrentStackLocation <span style="color:#f92672">=</span> a2<span style="color:#f92672">-&gt;</span>Tail.Overlay.CurrentStackLocation;
</span></span><span style="display:flex;"><span>  v18 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>i64;
</span></span><span style="display:flex;"><span>  FileObject <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>FileObject;
</span></span><span style="display:flex;"><span>  v19 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>i64;
</span></span><span style="display:flex;"><span>  v17[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>i64;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  MajorFunction <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>MajorFunction;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 处理IRP_MJ_SYSTEM_CONTROL请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> ( CurrentStackLocation<span style="color:#f92672">-&gt;</span>MajorFunction <span style="color:#f92672">==</span> IRP_MJ_SYSTEM_CONTROL )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v13 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CscProcessSystemControlIrp</span>((<span style="color:#66d9ef">__int64</span>)CscDeviceObject, a2);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_23;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 处理IRP_MJ_SHUTDOWN请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> ( MajorFunction <span style="color:#f92672">==</span> IRP_MJ_SHUTDOWN )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">KeEnterCriticalRegion</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">LOBYTE</span>(v14) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    v9 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CscStoreFlushState</span>(v14);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">KeLeaveCriticalRegion</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_14;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 处理IRP_MJ_CREATE请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>MajorFunction )
</span></span><span style="display:flex;"><span>  {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .......
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FsContext2 <span style="color:#f92672">=</span> FileObject<span style="color:#f92672">-&gt;</span>FsContext2;
</span></span><span style="display:flex;"><span>    FsContext <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)FileObject<span style="color:#f92672">-&gt;</span>FsContext;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果是IRP_MJ_CREATE请求,大多都进不了这个if，实际上还是会由RxFsdDispatch()函数处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>FsContext2 <span style="color:#f92672">||</span> <span style="color:#f92672">*</span>(_WORD <span style="color:#f92672">*</span>)FsContext2 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0xEB0F</span> <span style="color:#f92672">||</span> FsContext2[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0xC5C00C5C</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( FileObject<span style="color:#f92672">-&gt;</span>FsContext <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((_WORD <span style="color:#f92672">*</span>)FsContext <span style="color:#f92672">+</span> <span style="color:#ae81ff">20</span>) <span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>((_WORD <span style="color:#f92672">*</span>)FsContext <span style="color:#f92672">+</span> <span style="color:#ae81ff">28</span>) )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>             <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>               .......
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_13;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_22;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( MajorFunction <span style="color:#f92672">!=</span> IRP_MJ_DEVICE_CONTROL
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">||</span> ((CurrentStackLocation<span style="color:#f92672">-&gt;</span>Parameters.DeviceIoControl.IoControlCode <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x14018F</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFB</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>LABEL_22:
</span></span><span style="display:flex;"><span>    v13 <span style="color:#f92672">=</span> <span style="color:#a6e22e">RxFsdDispatch</span>((<span style="color:#66d9ef">__int64</span> (<span style="color:#66d9ef">__fastcall</span> <span style="color:#f92672">**</span>)())CscDeviceObject, a2, a3, a4);
</span></span><span style="display:flex;"><span>LABEL_23:
</span></span><span style="display:flex;"><span>    v9 <span style="color:#f92672">=</span> v13;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_15;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   .......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>RxFsdDispatch()函数实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>NTSTATUS <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">RxFsdDispatch</span>(PRDBSS_DEVICE_OBJECT RxDeviceObject, PIRP Irp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   .......
</span></span><span style="display:flex;"><span>  CurrentStackLocation <span style="color:#f92672">=</span> Irp<span style="color:#f92672">-&gt;</span>Tail.Overlay.CurrentStackLocation;
</span></span><span style="display:flex;"><span>  isCreate <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  MajorFunction <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>MajorFunction;
</span></span><span style="display:flex;"><span>  FileObject <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>FileObject;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> ( (_BYTE)MajorFunction )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> IRP_MJ_SYSTEM_CONTROL:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">RxSystemControl</span>(RxDeviceObject, Irp, MajorFunction, RxDeviceObject);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> IRP_MJ_CREATE_MAILSLOT:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> IRP_MJ_CREATE_NAMED_PIPE:
</span></span><span style="display:flex;"><span>      v11 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xC0000033</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果是IRP_MJ_CREATE请求，则使用默认的DispatchVector即RxFsdDispatchVector 然后调用RxFsdCommonDispatch()处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> IRP_MJ_CREATE:
</span></span><span style="display:flex;"><span>      isCreate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_9;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 默认则是取FsContext中的PrivateDispatchVector成员作为DispatchVector，其中FsContext为FCB(file control block)结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> ( FileObject )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        v8 <span style="color:#f92672">=</span> FileObject<span style="color:#f92672">-&gt;</span>FsContext;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( v8 )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( (v8<span style="color:#f92672">-&gt;</span>field_0 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFF0</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xEC20</span> )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            PrivateDispatchVector <span style="color:#f92672">=</span> v8<span style="color:#f92672">-&gt;</span>PrivateDispatchVector;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果PrivateDispatchVector不为null,则使用PrivateDispatchVector，否则使用RxFsdDispatchVector进行调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> ( PrivateDispatchVector )
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>LABEL_10:
</span></span><span style="display:flex;"><span>              result <span style="color:#f92672">=</span> <span style="color:#a6e22e">RxFsdCommonDispatch</span>(
</span></span><span style="display:flex;"><span>                         PrivateDispatchVector,
</span></span><span style="display:flex;"><span>                         Irp,
</span></span><span style="display:flex;"><span>                         (LARGE_INTEGER)FileObject,
</span></span><span style="display:flex;"><span>                         (<span style="color:#66d9ef">__int64</span>)RxDeviceObject);
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>isCreate )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> ( result <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8000002D</span> )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">260</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>LABEL_9:
</span></span><span style="display:flex;"><span>          PrivateDispatchVector <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>RxFsdDispatchVector;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">goto</span> LABEL_10;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      v11 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xC0000010</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   .......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中RxFsdDispatchVector结构体如下：</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//573d90a6-7408-4c17-aa76-723e42c752e2.png" alt=""  />
</p>
<p>其中回调函数类型为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">NTSTATUS</span> (<span style="color:#a6e22e">__stdcall</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">CommonRoutine</span>)(<span style="color:#a6e22e">PRX_CONTEXT</span>, <span style="color:#a6e22e">PIRP</span>)
</span></span></code></pre></div><p>接下来看RxFsdCommonDispatch的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">RxFsdCommonDispatch</span>(_RX_FSD_DISPATCH_VECTOR <span style="color:#f92672">*</span>a1, PIRP a2, LARGE_INTEGER a3, <span style="color:#66d9ef">__int64</span> a4)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">​</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  RxDeviceObject <span style="color:#f92672">=</span> (PRDBSS_DEVICE_OBJECT)a4;
</span></span><span style="display:flex;"><span>  Interval <span style="color:#f92672">=</span> a3;
</span></span><span style="display:flex;"><span>  v82 <span style="color:#f92672">=</span> a1;
</span></span><span style="display:flex;"><span>  v7 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  CurrentStackLocation <span style="color:#f92672">=</span> a2<span style="color:#f92672">-&gt;</span>Tail.Overlay.CurrentStackLocation;
</span></span><span style="display:flex;"><span>  v90 <span style="color:#f92672">=</span> CurrentStackLocation;
</span></span><span style="display:flex;"><span>  MajorFunction <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>MajorFunction;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(v23, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(NEW_PRX_CONTEXT));
</span></span><span style="display:flex;"><span>  v23<span style="color:#f92672">-&gt;</span>IrpTypeFlag <span style="color:#f92672">=</span> v25;
</span></span><span style="display:flex;"><span>  v23<span style="color:#f92672">-&gt;</span>CurrentNodeNumber <span style="color:#f92672">=</span> CurrentNodeNumber;
</span></span><span style="display:flex;"><span>  v23<span style="color:#f92672">-&gt;</span>field_1AA <span style="color:#f92672">=</span> LockArray_high;
</span></span><span style="display:flex;"><span>  v26 <span style="color:#f92672">=</span> RxDeviceObject;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 初始化PRX_CONTEXT对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">RxInitializeContext</span>(a2, RxDeviceObject, InitialContextFlags, v23);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  v41 <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>MajorFunction;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 根据MajorFunction获得调度函数 由于IRP_MJ_CREATE是0，所以选用的调度函数应该是RxCommonCreate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  CommonRoutine <span style="color:#f92672">=</span> v82[CurrentStackLocation<span style="color:#f92672">-&gt;</span>MajorFunction].CommonRoutine;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  MinorFunction <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>MinorFunction;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 根据MinorFunction来确定单次调用还是多次调用函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> ( (MinorFunction <span style="color:#f92672">&amp;</span> IRP_MN_QUERY_SINGLE_INSTANCE) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>    v70 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>LABEL_56:
</span></span><span style="display:flex;"><span>    v23<span style="color:#f92672">-&gt;</span>processFunc <span style="color:#f92672">=</span> (<span style="color:#66d9ef">__int64</span>)CommonRoutine;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( CommonRoutine )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v23<span style="color:#f92672">-&gt;</span>field_22 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v70 )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 单次调用调度函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        v7 <span style="color:#f92672">=</span> <span style="color:#a6e22e">RxFsdPostRequest</span>((PRX_CONTEXT)v23);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 多次调用调度函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">LODWORD</span>(v23<span style="color:#f92672">-&gt;</span>field_B0) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 调用单次函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          v7 <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">__int64</span> (<span style="color:#66d9ef">__fastcall</span> <span style="color:#f92672">*</span>)(NEW_PRX_CONTEXT <span style="color:#f92672">*</span>, PIRP))CommonRoutine)(v23, a2);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">==</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>)STATUS_RDBSS_RESTART_OPERATION )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>             <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            .......
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">==</span> STATUS_PENDING )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">!=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>)STATUS_RDBSS_RESTART_OPERATION )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            irp <span style="color:#f92672">=</span> v23<span style="color:#f92672">-&gt;</span>irp;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>irp
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">||</span> irp <span style="color:#f92672">!=</span> a2
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">||</span> v23<span style="color:#f92672">-&gt;</span>CurrentStackLocation <span style="color:#f92672">!=</span> CurrentStackLocation
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">||</span> v23<span style="color:#f92672">-&gt;</span>MajorFunction <span style="color:#f92672">!=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>MajorFunction
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">||</span> v23<span style="color:#f92672">-&gt;</span>MinorFunction <span style="color:#f92672">!=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>MinorFunction )
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>               <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>               .......
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            v23<span style="color:#f92672">-&gt;</span>field_22 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">RxCompleteRequestEx</span>((PRX_CONTEXT)v23, v23<span style="color:#f92672">-&gt;</span>irp);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> LABEL_214;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v7 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741822</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_214;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span></code></pre></div><p>根据以上分析该函数会调用RxCommonCreate进行处理，这里主要分析FsContext的赋值，下面看RxCommonCreate的实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">RxCommonCreate</span>(NEW_PRX_CONTEXT <span style="color:#f92672">*</span>Context, IRP <span style="color:#f92672">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  CurrentStackLocation <span style="color:#f92672">=</span> a2<span style="color:#f92672">-&gt;</span>Tail.Overlay.CurrentStackLocation;
</span></span><span style="display:flex;"><span>  FileObject <span style="color:#f92672">=</span> CurrentStackLocation<span style="color:#f92672">-&gt;</span>FileObject;
</span></span><span style="display:flex;"><span>  v25 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>i64;
</span></span><span style="display:flex;"><span>  v29 <span style="color:#f92672">=</span> FileObject;
</span></span><span style="display:flex;"><span>  p_FileName <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>FileObject<span style="color:#f92672">-&gt;</span>FileName;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// FileName为空RelatedFileObject为null并且则是使用RxDeviceFCB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>FileObject<span style="color:#f92672">-&gt;</span>FileName.Length <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>FileObject<span style="color:#f92672">-&gt;</span>RelatedFileObject )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    FileObject<span style="color:#f92672">-&gt;</span>FsContext2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>i64;
</span></span><span style="display:flex;"><span>    FileObject<span style="color:#f92672">-&gt;</span>FsContext <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>RxDeviceFCB;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span><span style="color:#a6e22e">LODWORD</span>(RxDeviceFCB.field_B8);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span><span style="color:#a6e22e">LODWORD</span>(RxDeviceFCB.field_B0);
</span></span><span style="display:flex;"><span>    a2<span style="color:#f92672">-&gt;</span>IoStatus.Information <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>i64;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .......
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>i64;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> <span style="color:#a6e22e">RxpInitializeCreateContext</span>(Context);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( (<span style="color:#66d9ef">int</span>)result <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 这里判断Options是否包含FILE_CREATE_TREE_CONNECTION标志位，在RxCreateTreeConnect中会赋值 FileObject-&gt;FsContext = &amp;RxDeviceFCB;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> ( (CurrentStackLocation<span style="color:#f92672">-&gt;</span>Parameters.Create.Options <span style="color:#f92672">&amp;</span> FILE_CREATE_TREE_CONNECTION) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    TreeConnect <span style="color:#f92672">=</span> <span style="color:#a6e22e">RxCreateTreeConnect</span>((PRX_CONTEXT)Context);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_22;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  .......
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( p_FileName<span style="color:#f92672">-&gt;</span>Length <span style="color:#f92672">&amp;&amp;</span> FileObject<span style="color:#f92672">-&gt;</span>FileName.Buffer[((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span>)p_FileName<span style="color:#f92672">-&gt;</span>Length <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\\&#39;</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 不能包含FILE_NON_DIRECTORY_FILE会出错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> ( (CurrentStackLocation<span style="color:#f92672">-&gt;</span>Parameters.Create.Options <span style="color:#f92672">&amp;</span> FILE_NON_DIRECTORY_FILE会出错) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        .......
</span></span><span style="display:flex;"><span>        TreeConnect <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xC0000033</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> LABEL_20;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      p_FileName<span style="color:#f92672">-&gt;</span>Length <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">WORD1</span>(Context<span style="color:#f92672">-&gt;</span>field_2D8) <span style="color:#f92672">|=</span> <span style="color:#ae81ff">2u</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeConnect <span style="color:#f92672">=</span> <span style="color:#a6e22e">RxCanonicalizeNameAndObtainNetRoot</span>(Context, a2, <span style="color:#f92672">&amp;</span>p_FileName<span style="color:#f92672">-&gt;</span>Length, <span style="color:#f92672">&amp;</span>v25);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( TreeConnect <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0xC0000016</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_20;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .......
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 会在RxCreateFromNetRoot-&gt;RxSetupNetFileObject设置FsContext 经过调试其PrivateDispatchVector一般为null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    TreeConnect <span style="color:#f92672">=</span> <span style="color:#a6e22e">RxCreateFromNetRoot</span>(Context, a2, (PIRP)<span style="color:#f92672">&amp;</span>v25);
</span></span></code></pre></div><p>RxDeviceFCB在RxInitializeDispatchVectors()函数中初始化PrivateDispatchVector成员</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//9d601793-ad7c-48b5-a449-d0aebbaf52fa.png" alt=""  />
</p>
<p>可以看到默认的RxDeviceFCBVector支持的调用并不是很多</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//7f67e04f-3550-4870-9210-6fa3957c68ed.png" alt=""  />
</p>
<h4 id="513-用户态进程对打开的文件进程操作例如deviceiocontrol读写等">5.1.3 用户态进程对打开的文件进程操作，例如DeviceIoControl、读写等<a hidden class="anchor" aria-hidden="true" href="#513-用户态进程对打开的文件进程操作例如deviceiocontrol读写等">#</a></h4>
<p>这个状态和上一个状态的调用流程差不多，只是调度函数有所不同。以fsDeviceIoControl会调用RxCommonDevFCBIoCtl。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//f3437e8d-5e89-4e0f-870f-ae855371efc4.png" alt=""  />
</p>
<p>RxCommonDevFCBIoCtl调用RxXXXControlFileCallthru从而调用csc.sys的调度表。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//e4f03503-75a0-41b9-b3ac-f2d6e23018e4.png" alt=""  />
</p>
<p>在RxXXXControlFileCallthru会调用RxLowIoPopulateFsctlInf()会根据IoControlCode的标志位选用不同buffer。</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//684421a4-d841-4dbb-9849-25847c39d2c1.png" alt=""  />
</p>
<p>下面以Exp的流程为例，回顾以下整个流程：</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//2b5ff1eb-07f5-4681-840c-523626c8e668.png" alt=""  />
</p>
<p>最后看一下逆向后在csc.sys的patch代码：</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//3baa42ad-26df-43a4-b86a-2af70fc4f2fa.png" alt=""  />
</p>
<h2 id="五exp分析">五、Exp分析<a hidden class="anchor" aria-hidden="true" href="#五exp分析">#</a></h2>
<p>利用就比较简单：</p>
<ul>
<li>首先使用NtQuerySystemInformation获得当前进程的eprocess和系统进程的eprocess进程的地址；</li>
<li>然后使用任意写0当前线程的_KTHREAD的结构的PreviouseMode改为0即为kernel mode；</li>
<li>此时使用NtReadVirtualMemory和NtWriteVirtualMemory由于_KTHREAD的PreviouseMode为0(kernel mode)，即当前线程认为是内核线程，则内核不再检查读写的地址是否为用户态，从而达到任意地址写读；</li>
<li>最后是将系统token替换当前token达到提权。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#a6e22e">RtlInitUnicodeString</span>(<span style="color:#f92672">&amp;</span>objectName, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Device</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Mup</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">;Csc</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">.&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">InitializeObjectAttributes</span>(<span style="color:#f92672">&amp;</span>objectAttr, <span style="color:#f92672">&amp;</span>objectName, <span style="color:#ae81ff">0</span>, NULL, NULL);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> status <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtCreateFile</span>(<span style="color:#f92672">&amp;</span>handle, SYNCHRONIZE, <span style="color:#f92672">&amp;</span>objectAttr, <span style="color:#f92672">&amp;</span>iosb, NULL, FILE_ATTRIBUTE_NORMAL, <span style="color:#ae81ff">0</span>, FILE_OPEN_IF, FILE_CREATE_TREE_CONNECTION, NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">NT_SUCCESS</span>(status))
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] NtCreateFile failed with status = %x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, status);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>Exp进行fsIoControl文件的路径\Device\Mup\;Csc\.\.  这个路径实际上是通用命名约定 (Universal Naming Convention， UNC)的写法，UNC 名称必须遵循 \SERVERNAME\SHARENAME 语法，在这里</p>
<ul>
<li>
<p>SERVERNAME为Csc</p>
</li>
<li>
<p>SHARENAME 为.\.</p>
<p><img loading="lazy" src="/attachments/2024-07-03-cve-2024-26229windows-rdbss//97cd192d-11c1-48b8-8f8f-844b6acface7.png" alt=""  />
</p>
<p>通过winobj可以看到csc驱动的符号链接为\Device\Mup\;Csc，至于为什么后面加上.\.，这里还没有研究清楚，即mup.sys和csc.sys关系没有研究清楚。</p>
</li>
</ul>
<h2 id="六总结">六、总结<a hidden class="anchor" aria-hidden="true" href="#六总结">#</a></h2>
<p>本文首先介绍了漏洞所在驱动的作用，然后通过漏洞成因以及补丁分析确定漏洞点。在确定漏洞点后，主要分析漏洞触发的整个过程，并简要分析了该漏洞exp的原理。</p>
<p>总体来说，这个漏洞的漏洞模式比较简单，不易被发现的原因是触发流程过长而且还涉及到多个驱动之间的间接调用，如果不是专门研究这个驱动，很难会分析到漏洞所在的函数。希望通过本文的介绍可以让读者熟悉rdbss驱动的相关机制从而更容易挖掘使用rdbss机制相关驱动的漏洞。</p>
<h2 id="七参考链接">七、参考链接<a hidden class="anchor" aria-hidden="true" href="#七参考链接">#</a></h2>
<ul>
<li><a href="https://doxygen.reactos.org/d8/d89/rdbss_8c_source.html">https://doxygen.reactos.org/d8/d89/rdbss_8c_source.html</a></li>
<li><a href="https://www.cnblogs.com/lsh123/p/7354573.html">应用程序与驱动程序通信 DeviceIoControl</a></li>
<li><a href="https://forum.butian.net/share/3101">cve-2024-26229 漏洞分析</a></li>
<li><a href="https://github.com/varwara/CVE-2024-26229">CVE-2024-26229</a></li>
<li><a href="https://www.youtube.com/watch?v=2eHsnZ4BeDI">OffensiveCon24 - Eric Egsgard - Almost Escaping the Sandbox: Attacking Windows Device Drivers</a></li>
</ul>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blog/tiangongarticle001/">
    <span class="title">« 上一页</span>
    <br>
    <span>CVE-2023-0179 Linux内核提权</span>
  </a>
</nav>





  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://poc.qianxin.com/home">天工实验室</a></span>
        

    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
