<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Rust逆向入门：从反编译视角学习内存模型 | 天工实验室</title>
<meta name="keywords" content="Rust, Memory Model, Decompile">
<meta name="description" content="Rust逆向入门：从反编译视角学习内存模型 一、前言 Rust反编译一直是比较困难的问题，Rust强调零成本抽象，在使用高级特性（如泛型、闭包、迭代器等）时为了不引入额外的运行时开销，编译器会生成高度优化且复杂的机器码，从而难以直接恢复高层的抽象结构，除此之外，Rust 的所有权系统及其借用检查器在编译过程中被彻底消解成运行时代码。这个过程生成了许多低级的内存管理代码，这些代码在反编译时难以重新构建成高层次的所有权和生命周期语义。尽管反编译 Rust 代码有诸多困难，但进行 Rust 反编译依然具备现实意义，例如分析闭源Rust代码，寻找潜在的安全漏洞。本文旨在学习Rust基本内存数据结构及其内存布局，并且通过反编译视角理解Rust编译器到底做了什么事。
值得注意的时，Rust目前没有确定内存模型，因此本文谈到的是Rustc编译器实现的Rust模型。
Rust 目前没有确定内存模型
Rust does not yet have a defined memory model. Various academics and industry professionals are working on various proposals, but for now, this is an under-defined place in the language.
二、反编译器准备 本文中的很多例子会使用到反编译工具，例如IDA或者ghidra。ghidra在11版本以后增加了对Rust支持，在使用ghidra进行反编译Rust工具时只需要选中Demangler Rust即可。
IDA则需要额外的IDARustDemangler插件，不管是ghidra的Demangler Rust功能亦或是IDARustDemangler插件，其功能都是将Rust二进制文件中经过编译器mangle过的符号进行demangle，得到原始符号，以下以IDA得视角对比了demangle之前与demangle之后得代码视图，可以看到可读性大大增加。
demangle之前：
demangle之后：
三、函数调用__Rustcall 在x86_64平台UNIX系统下面，Rust遵循System V ABI，即传参会通过rdi、rsi、rdx、rcx、r8、r9等，返回值会通过rax，在某些情况下，compiler会进行返回值优化（Return Value Optimization，RVO），这时候函数调用约定就会发生变化，返回值不再是使用rax进行传递，而是使用rdi（函数的第一个参数）。以如下例子为例，我们查看ghidra编译器到底做了什么？
fn add_str_ret_str(a:&amp;str,b:&amp;str)-&gt;String{ return a.to_string()&#43;&amp;b.to_string(); } 对于上述代码，因为在返回时新建了对象（没有新建对象不会触发RVO，此时依旧通过rax传递对象），会触发返回值优化，使得返回值通过第一个参数进行传递。
IDA视角下得Rustcall，IDA会将第一个参数命名为retstr，提醒用户这个字段是返回值。
在ghidra视角下rust调用使用__rustcall关键字标识，ghidra使用return_storage_ptr来标记返回值。
四、Rust内存布局 在Rust中基本类型、引用（存储的是变量的地址，大小为8字节）、数组（连续内存块）与传统的C、C&#43;&#43;内存布局一样，因此本文不再赘述。本文主要探究Rust特有实现，例如动态数组、String、动态大小类型（Dynamic Sized Type，DST）。
4.1 动态数组与String Rust中的动态数组Vec以及String类型的底层实现与C&#43;&#43;容器相同，其采用三个部分来表示，分别是：
pointer：指向数据字节流buffer中存储的数据； length：buffer中字节流的字节长度； capacity：buffer的长度。 实际上看String的实现，会发现String的实现基于Vec，以下代码摘自Rust底层实现：">
<meta name="author" content="b4tm4n">
<link rel="canonical" href="http://localhost:1313/blog/tiangongarticle039/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9b0c42f9222bc665b5845e6199fc07fd87b025125d3366cc5f873b0f54ca8481.css" integrity="sha256-mwxC&#43;SIrxmW1hF5hmfwH/YewJRJdM2bMX4c7D1TKhIE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/blog/tiangongarticle039/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="天工实验室 (Alt + H)">
                <img src="http://localhost:1313/logo/logo3.png" alt="" aria-label="logo"
                    height="100" style="margin-top: 15px;">
            </a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://poc.qianxin.com/home" title="破壳官网">
                    <span>破壳官网</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blog/">博客</a></div>
    <h1 class="post-title entry-hint-parent">
      Rust逆向入门：从反编译视角学习内存模型
    </h1>
    <div class="post-meta"><span title='2024-07-17 00:00:00 +0000 UTC'>2024年07月17日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;b4tm4n

</div>
  </header>

  <div class="author">
    <div class="author_avatar">
      <img src="/authors/b4tm4n.jpg" alt="b4tm4n">
    </div>
    <div class="author_info">
      <span class="author_id">b4tm4n</span>
      <p class="author_description">二进制程序分析、模糊测试</p>
    </div>
  </div>
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/rust/">Rust</a></li>
      <li><a href="http://localhost:1313/tags/memory-model/">Memory Model</a></li>
      <li><a href="http://localhost:1313/tags/decompile/">Decompile</a></li>
    </ul><br/> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#rust%e9%80%86%e5%90%91%e5%85%a5%e9%97%a8%e4%bb%8e%e5%8f%8d%e7%bc%96%e8%af%91%e8%a7%86%e8%a7%92%e5%ad%a6%e4%b9%a0%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" aria-label="Rust逆向入门：从反编译视角学习内存模型">Rust逆向入门：从反编译视角学习内存模型</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%89%8d%e8%a8%80" aria-label="一、前言">一、前言</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%8d%e7%bc%96%e8%af%91%e5%99%a8%e5%87%86%e5%a4%87" aria-label="二、反编译器准备">二、反编译器准备</a></li>
                <li>
                    <a href="#%e4%b8%89%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8__rustcall" aria-label="三、函数调用__Rustcall">三、函数调用__Rustcall</a></li>
                <li>
                    <a href="#%e5%9b%9brust%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80" aria-label="四、Rust内存布局">四、Rust内存布局</a><ul>
                        
                <li>
                    <a href="#41-%e5%8a%a8%e6%80%81%e6%95%b0%e7%bb%84%e4%b8%8estring" aria-label="4.1 动态数组与String">4.1 动态数组与String</a></li>
                <li>
                    <a href="#42-fat-pointer" aria-label="4.2 Fat Pointer">4.2 Fat Pointer</a><ul>
                        
                <li>
                    <a href="#dst" aria-label="DST">DST</a></li></ul>
                </li>
                <li>
                    <a href="#43-enum" aria-label="4.3 ENUM">4.3 ENUM</a></li>
                <li>
                    <a href="#44-struct" aria-label="4.4 Struct">4.4 Struct</a></li>
                <li>
                    <a href="#45-box" aria-label="4.5 Box">4.5 Box</a></li>
                <li>
                    <a href="#46-rc" aria-label="4.6 Rc">4.6 Rc</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%94%e6%80%bb%e7%bb%93" aria-label="五、总结">五、总结</a><ul>
                        
                <li>
                    <a href="#%e5%85%ad%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3" aria-label="六、参考文档">六、参考文档</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="rust逆向入门从反编译视角学习内存模型">Rust逆向入门：从反编译视角学习内存模型<a hidden class="anchor" aria-hidden="true" href="#rust逆向入门从反编译视角学习内存模型">#</a></h1>
<h2 id="一前言">一、前言<a hidden class="anchor" aria-hidden="true" href="#一前言">#</a></h2>
<p>Rust反编译一直是比较困难的问题，Rust强调零成本抽象，在使用高级特性（如泛型、闭包、迭代器等）时为了不引入额外的运行时开销，编译器会生成高度优化且复杂的机器码，从而难以直接恢复高层的抽象结构，除此之外，Rust 的所有权系统及其借用检查器在编译过程中被彻底消解成运行时代码。这个过程生成了许多低级的内存管理代码，这些代码在反编译时难以重新构建成高层次的所有权和生命周期语义。尽管反编译 Rust 代码有诸多困难，但进行 Rust 反编译依然具备现实意义，例如分析闭源Rust代码，寻找潜在的安全漏洞。本文旨在学习Rust基本内存数据结构及其内存布局，并且通过反编译视角理解Rust编译器到底做了什么事。</p>
<p>值得注意的时，Rust目前没有确定内存模型，因此本文谈到的是Rustc编译器实现的Rust模型。</p>
<blockquote>
<p>Rust 目前没有确定内存模型</p>
<p>Rust does not yet have a defined memory model. Various academics and industry professionals are working on various proposals, but for now, this is an under-defined place in the language.</p>
</blockquote>
<!-- raw HTML omitted -->
<h2 id="二反编译器准备">二、反编译器准备<a hidden class="anchor" aria-hidden="true" href="#二反编译器准备">#</a></h2>
<p>本文中的很多例子会使用到反编译工具，例如IDA或者ghidra。ghidra在11版本以后增加了对Rust支持，在使用ghidra进行反编译Rust工具时只需要选中<strong>Demangler Rust</strong>即可。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/2e8ade78-d9bb-4f93-8d4c-7d8cbca2cb51.png" alt=""  />
</p>
<p>IDA则需要额外的<a href="https://github.com/timetravelthree/IDARustDemangler.git">IDARustDemangler插件</a>，不管是ghidra的<strong>Demangler Rust</strong>功能亦或是IDARustDemangler插件，其功能都是将Rust二进制文件中经过编译器mangle过的符号进行demangle，得到原始符号，以下以IDA得视角对比了demangle之前与demangle之后得代码视图，可以看到可读性大大增加。</p>
<p>demangle之前：</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/ac2afd76-4051-428c-a694-513624d5aff5.png" alt=""  />
</p>
<p>demangle之后：</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/6342098f-4e2b-445e-b48c-9210564140c4.png" alt=""  />
</p>
<h2 id="三函数调用__rustcall">三、函数调用__Rustcall<a hidden class="anchor" aria-hidden="true" href="#三函数调用__rustcall">#</a></h2>
<p>在x86_64平台UNIX系统下面，Rust遵循System V ABI，即传参会通过rdi、rsi、rdx、rcx、r8、r9等，返回值会通过rax，在某些情况下，compiler会进行返回值优化（Return Value Optimization，RVO），这时候函数调用约定就会发生变化，返回值不再是使用rax进行传递，而是使用rdi（函数的第一个参数）。以如下例子为例，我们查看ghidra编译器到底做了什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add_str_ret_str</span>(a:<span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,b:<span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>)-&gt;String{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a.to_string()<span style="color:#f92672">+&amp;</span>b.to_string();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于上述代码，因为在<strong>返回时新建了对象</strong>（没有新建对象不会触发RVO，此时依旧通过rax传递对象），会触发返回值优化，使得返回值通过<strong>第一个参数</strong>进行传递。</p>
<p>IDA视角下得Rustcall，IDA会将第一个参数命名为retstr，提醒用户这个字段是返回值。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/615f2a01-e141-4f53-9fc3-2112639be5ad.png" alt=""  />
</p>
<p>在ghidra视角下rust调用使用__rustcall关键字标识，ghidra使用return_storage_ptr来标记返回值。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/473f16a7-5009-4cb8-9b7a-e183c728ef87.png" alt=""  />
</p>
<h2 id="四rust内存布局">四、Rust内存布局<a hidden class="anchor" aria-hidden="true" href="#四rust内存布局">#</a></h2>
<p>在Rust中基本类型、引用（存储的是变量的地址，大小为8字节）、数组（连续内存块）与传统的C、C++内存布局一样，因此本文不再赘述。本文主要探究Rust特有实现，例如动态数组、String、动态大小类型（Dynamic Sized Type，DST）。</p>
<h3 id="41-动态数组与string">4.1 动态数组与String<a hidden class="anchor" aria-hidden="true" href="#41-动态数组与string">#</a></h3>
<p>Rust中的动态数组Vec以及String类型的底层实现与C++容器相同，其采用三个部分来表示，分别是：</p>
<ol>
<li>pointer：指向数据字节流buffer中存储的数据；</li>
<li>length：buffer中字节流的字节长度；</li>
<li>capacity：buffer的长度。</li>
</ol>
<p>实际上看String的实现，会发现String的实现基于Vec，以下代码摘自Rust底层实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(PartialEq, PartialOrd, Eq, Ord)]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[stable(feature = </span><span style="color:#e6db74">&#34;rust1&#34;</span><span style="color:#75715e">, since = </span><span style="color:#e6db74">&#34;1.0.0&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg_attr(not(test), lang = </span><span style="color:#e6db74">&#34;String&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> String {
</span></span><span style="display:flex;"><span>    vec: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[stable(feature = </span><span style="color:#e6db74">&#34;rust1&#34;</span><span style="color:#75715e">, since = </span><span style="color:#e6db74">&#34;1.0.0&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg_attr(not(test), rustc_diagnostic_item = </span><span style="color:#e6db74">&#34;Vec&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[rustc_insignificant_dtor]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> Vec<span style="color:#f92672">&lt;</span>T, <span style="color:#75715e">#[unstable(feature = </span><span style="color:#e6db74">&#34;allocator_api&#34;</span><span style="color:#75715e">, issue = </span><span style="color:#e6db74">&#34;32838&#34;</span><span style="color:#75715e">)]</span> A: <span style="color:#a6e22e">Allocator</span> <span style="color:#f92672">=</span> Global<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    buf: <span style="color:#a6e22e">RawVec</span><span style="color:#f92672">&lt;</span>T, A<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    len: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[allow(missing_debug_implementations)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RawVec</span><span style="color:#f92672">&lt;</span>T, A: <span style="color:#a6e22e">Allocator</span> <span style="color:#f92672">=</span> Global<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    ptr: <span style="color:#a6e22e">Unique</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    cap: <span style="color:#a6e22e">Cap</span>,
</span></span><span style="display:flex;"><span>    alloc: <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面我们看看这样一个简单的程序，其在堆上创建了一个动态数组，数组的每个元素存储String类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span>  vec <span style="color:#f92672">=</span>vec![<span style="color:#e6db74">&#34;hello&#34;</span>.to_string(),<span style="color:#e6db74">&#34;world&#34;</span>.to_string()];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//vec[1]=&#34;rust&#34;.to_string();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>,vec)
</span></span></code></pre></div><p>其DeBug模式下反编译对应的部分代码如下，观察整个代码可以看到程序做了以下事情 ：</p>
<ol>
<li>调用<code>exchange_malloc</code>分配vec动态数组<code>vec</code>；</li>
<li>两次调用<code>to_string</code>分别创建<code>&quot;hello&quot;</code>、<code>&quot;world&quot; String</code>；（self_8以及v8，注意！这里由于RVO，函数使用第一个参数传递返回值）</li>
<li>使用vec存储两个String。</li>
</ol>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/9315fe12-14ef-46f7-b480-702e7826fca3.png" alt=""  />
</p>
<p>可以看到整体的代码变得可读性不是很高，出现了与源代码有很多出入的部分，例如<code>std::catch_unwind</code>、<code>&lt;alloc::vec::Vec&lt;TA&gt;,_as_core::fmt::Debug&gt;::fmt</code>等，这部分代码是由<code>println!</code>宏展开得到。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">exchange_malloc</span>(size: <span style="color:#66d9ef">usize</span>, align: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">u8</span>
</span></span></code></pre></div><p>除此之外，可以看到程序调用exchange_malloc分配堆上内存，exchange_malloc的第一个参数为分配内存的大小，第二个参数为内存对齐字节。这里函数分配了<strong>0x30大小</strong>的堆上内存来存储2个String类型的变量。由此可以看到，每个String类型占据<strong>0x18</strong>大小的内存，分别用来存储ptr、capicity以及length（每个元素占用8个字节）。所以实际上内存布局如下图（由于结构体变量顺序可能由于内存对齐等问题进行重排，因此ptr、cap、len顺序可能会发生变化）：</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/a34befc7-8a1a-40ac-80fa-3851fe155a55.png" alt=""  />
</p>
<p>上面是debug模式下反编译器观察到的代码，String与Vec在release模式下看可能更明显的辨别出来，例如其会使用两个常量值来表明length以及capicity、使用一个指针指向实际数据。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/07405d9a-159b-4fbd-a851-72ba04767902.png" alt=""  />
</p>
<p>观察一下debug版本中<code>&quot;hello&quot;.to_string()</code> ，to_string函数的函数签名为fn to_string(&amp;self)-&gt; String，而实际调用to_string的汇编代码如下，to_string对应的汇编代码：</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/7a99e671-9d3b-438d-8176-f1b09f8bec09.png" alt=""  />
</p>
<p>可以看到<code>to_string</code>函数调用实际上传递了3个实参，第一个是返回值rdi，那第二、三个参数是什么？是&quot;hello&quot;字符串嘛？那第三个参数是什么？ 这里直接给出答案：<strong>第二个是&quot;hello&quot;字符串地址，第三个是长度</strong>，那么为什么一个&quot;hello&quot;（这里的&quot;hello&quot;类型是str，即<strong>字符串切片</strong>）需要传递两个参数？这里不得不提一下胖指针（fat pointer）。</p>
<h3 id="42-fat-pointer">4.2 Fat Pointer<a hidden class="anchor" aria-hidden="true" href="#42-fat-pointer">#</a></h3>
<p>Fat pointer实际上相当于<strong>两个指针，其中一个指针指向数据，另一个指针携带数据相关的metadata</strong>。在Rust语言中，Fat pointer主要用于DST，从而让编译器在编译时便可以静态知道类型的大小。那么什么是DST呢？</p>
<h4 id="dst">DST<a hidden class="anchor" aria-hidden="true" href="#dst">#</a></h4>
<blockquote>
<p>A fat pointer contains a pointer plus some information that makes the DST &ldquo;complete&rdquo; (e.g. the length).</p>
</blockquote>
<p>DST是Dynamic Sized Types，即动态大小类型，指的是&quot;<strong>编译器静态无法获取该类型大小，只能在运行时动态获得</strong>&quot;。 在Rust里面，属于DST的有四类：[T]和str、特征对象、DST和外部类型。</p>
<ol>
<li>
<p>切片[T]和str</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//str示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s1: <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello there!&#34;</span>;     <span style="color:#75715e">//DST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s2: <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;How&#39;s it going?&#34;</span>;  <span style="color:#75715e">//DST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">//切片示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">let</span> arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];   
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">3</span>]   <span style="color:#75715e">//DST
</span></span></span></code></pre></div></li>
<li>
<p>特征对象(Trait Object)：类似于C++里的多态 ，后面我们会通过具体例子来讲解。</p>
</li>
</ol>
<p>其他：由于本文探究Rust常见数据类型，因此本文不关注自定义DST和外部类型。</p>
<p><strong>[T]与str</strong></p>
<p>首先我们看切片与str，我们通过<code>std::mem::size_of</code>查看不同类型的输出，可以看到因为<code>&amp;u32</code>与<code>&amp;[u32;2]</code>的大小在运行时可知，因此Rust编译器认为其为普通指针，大小为8字节。对于&amp;[u32]，由于[u32]的大小编译时无法知道（因为编译器只知道该切片的每个元素大小，但是不知道长度），编译器将其实现为16字节的Fat pointer。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>dbg!(std::mem::size_of::<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>());<span style="color:#75715e">//[src/main.rs:100:5] std::mem::size_of::&lt;&amp;u32&gt;() = 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>dbg!(std::mem::size_of::<span style="color:#f92672">&lt;&amp;</span>[<span style="color:#66d9ef">u32</span>; <span style="color:#ae81ff">2</span>]<span style="color:#f92672">&gt;</span>());<span style="color:#75715e">//[src/main.rs:101:5] std::mem::size_of::&lt;&amp;[u32; 2]&gt;() = 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>dbg!(std::mem::size_of::<span style="color:#f92672">&lt;&amp;</span>[<span style="color:#66d9ef">u32</span>]<span style="color:#f92672">&gt;</span>());<span style="color:#75715e">//[src/main.rs:102:5] std::mem::size_of::&lt;&amp;[u32]&gt;() = 16  因为[u32]是DST
</span></span></span></code></pre></div><p>在这种情况下，fat pointer类似于下面的结构，即一个指针指向数据buffer，一个指针保存buffer的长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SliceRef</span> { 
</span></span><span style="display:flex;"><span>    ptr: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u32</span>, 
</span></span><span style="display:flex;"><span>    len: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于str类型，len表示字节长度值；对于切片类型，表示的是数组元素的数目。</p>
<p><strong>特征对象</strong></p>
<p>特征对象（trait object）在Rust中使用Box&lt;dyn Trait&gt;或者&amp;dyn Trait来表示实现了某个Trait的对象，我们同样使用如下的例子来了解Rust的fat pointer，可以看到常规对象Cat运行时大小已知，因此指向其的引用（&amp;Cat）底层使用普通指针，而特征对象dyn Animal大小运行时未知（你不知道实现Animal Trait的对象有哪些），因此Rust底层使用fat pointer来表示，其大小为16字节。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Animal {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">speak</span>(<span style="color:#f92672">&amp;</span>self);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cat</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Animal <span style="color:#66d9ef">for</span> Cat {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">speak</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;meow&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dbg!(size_of::<span style="color:#f92672">&lt;&amp;</span>Cat<span style="color:#f92672">&gt;</span>());<span style="color:#75715e">//size_of::&lt;&amp;Cat&gt;()        = 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>dbg!(size_of::<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">dyn</span> Animal<span style="color:#f92672">&gt;</span>());<span style="color:#75715e">//size_of::&lt;&amp;dyn Animal&gt;() = 16
</span></span></span></code></pre></div><p>在这种情况下，fat pointer类似于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TraitObjectRef</span> {
</span></span><span style="display:flex;"><span>    data_ptr: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> (),
</span></span><span style="display:flex;"><span>    vptr: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> (),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中data_ptr指向实际的结构体，vptr指向trait包含的方法。</p>
<p>最后，我们通过如下一段代码来探究特征对象的底层内存模型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    name: String,
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">i8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    lives: <span style="color:#66d9ef">i8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Pet {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">talk</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Pet <span style="color:#66d9ef">for</span> Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">talk</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
</span></span><span style="display:flex;"><span>        format!(<span style="color:#e6db74">&#34;Woof, my name is </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">!&#34;</span>, self.name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Pet <span style="color:#66d9ef">for</span> Cat {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">talk</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
</span></span><span style="display:flex;"><span>        String::from(<span style="color:#e6db74">&#34;Miau!&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> pets: Vec<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Pet<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>        Box::new(Cat { lives: <span style="color:#ae81ff">9</span> }),
</span></span><span style="display:flex;"><span>        Box::new(Dog { name: String::from(<span style="color:#e6db74">&#34;Fido&#34;</span>), age: <span style="color:#ae81ff">5</span> }),
</span></span><span style="display:flex;"><span>    ];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> pet <span style="color:#66d9ef">in</span> pets {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Hello, who are you? </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, pet.talk());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其debug模式下反编译代码如下，关键部分都由注释解释，可以看到程序存在以下操作：</p>
<ol>
<li>通过exchange_malloc分配0x20大小的堆内存，vec指向该内存；</li>
<li>通过exchange_malloc分配1字节堆内存，对应的是Cat结构体；</li>
<li>通过exchange_malloc分配0x20字节堆内存，对应的Dog结构体（String类型的name占据0x18个字节，尽管age为i8类型，考虑到内存对齐，age占据0x8字节）；</li>
<li>将分配的cat结构体指针和Dog结构体指针存储到vec中，可以看到这里除了存储两个结构体指针外，额外分别存储了不同的变量（分别为v0、Dog_as_Rust_learn::Pet::vtable），其类似于C++中的虚函数表，用于存储特征对象实现的特征函数。</li>
</ol>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/927b61cf-05c5-4e7a-876e-db762605b158.png" alt=""  />
</p>
<p>在这种情况下，Rust内存布局如下，其中<code>vtable</code>前0x18字节为析构函数、<code>vtable</code>大小以及对齐值。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/f9667ee0-14fe-44e9-8719-636b57aae296.png" alt=""  />
</p>
<p>在release版本中，内存布局不会变化，但是会因为编译器的优化导致可读性非常差，例如编译器会展开循环（当循环次数不大的时候)，这就会导致你看不出来这是一个循环。例如如下代码：</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/cd6447ff-3ecf-4f6c-a97c-247f784ccf55.png" alt=""  />
</p>
<h3 id="43-enum">4.3 ENUM<a hidden class="anchor" aria-hidden="true" href="#43-enum">#</a></h3>
<p>Rust的enum属于<a href="https://en.wikipedia.org/wiki/Tagged_union">tagged union</a>，tagged union用来保存可以采用不同但固定的值的数据结构。任何时候只能使用其中一种类型，并且标记字段明确指示正在使用哪种类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">DummyEnum</span><span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span> A(Box<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span> B(Box<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，在Rust中，上面的enum在反编译视角看到的内容是，通过u8类型的discriminant值来表示当前enum类型指向的实际类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// DummyEnum {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     is_a_or_b: u8,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     data: usize,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }
</span></span></code></pre></div><p>看这样一段代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Name</span>{
</span></span><span style="display:flex;"><span>   A(String),
</span></span><span style="display:flex;"><span>   B(String)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span>Name::B(<span style="color:#e6db74">&#34;a&#34;</span>.to_string());
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">let</span> a<span style="color:#f92672">=</span>Name::A(<span style="color:#e6db74">&#34;b&#34;</span>.to_string());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其反编译代码如下，可以看到存在一个额外的数据存储discriminant。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/d1939e26-dd02-4068-b359-f98b45da7a9e.png" alt=""  />
</p>
<h3 id="44-struct">4.4 Struct<a hidden class="anchor" aria-hidden="true" href="#44-struct">#</a></h3>
<p>Rust结构体内存布局与其成员变量息息相关，如果存在Vec或者String类型的成员变量，则该变量采用(ptr、capacity、length)三元组来表示，如果存在DST，则使用fat pointer来表示，看看如下的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>     names:  Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>     slice:  <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>     dimension: (<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>),
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> novel <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Call me Ishmael. Some years ago...&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span>Data{
</span></span><span style="display:flex;"><span>    names:<span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[<span style="color:#e6db74">&#34;hello&#34;</span>.to_string(),<span style="color:#e6db74">&#34;world&#34;</span>.to_string()],
</span></span><span style="display:flex;"><span>    slice:<span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">novel</span>,
</span></span><span style="display:flex;"><span>    dimension:(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> };
</span></span></code></pre></div><p><img loading="lazy" src="/attachments/2024-07-17-rust/c5b13bbc-f3e5-48df-a34b-2593df882915.png" alt=""  title=" =1286x"  />
</p>
<p>上图为其对应的IDA反编译结果，由于篇幅问题，这里不进行详细解释，其内存布局为：</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/5d0cc43a-4401-45f4-a22b-0056bc0a22c4.png" alt=""  title=" =665.5x403"  />
</p>
<h3 id="45-box">4.5 Box<a hidden class="anchor" aria-hidden="true" href="#45-box">#</a></h3>
<p>Rust智能指针内存布局类似于类似传统的指针，这里不再赘述。</p>
<h3 id="46-rc">4.6 Rc<a hidden class="anchor" aria-hidden="true" href="#46-rc">#</a></h3>
<p>在Rust中，<code>Rc</code> 跟踪引用的数量，这相当于包裹在 <code>Rc</code> 值的所有者的数量，因此其除了指向数据之外，会存储数据对应的强引用（strong）、弱引用个数（weak）。当将 vector 包裹在智能指针 <code>Rc</code> 里时，用于存储 vector head 的三个机器字长（ptr、len、cap）会和引用计数一起分配到堆上。以如下的例子为例，其内存布局如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::Rc;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vec_var <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">2.0</span>, <span style="color:#ae81ff">3.0</span>];  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> foo <span style="color:#f92672">=</span> Rc::new(vec_var);  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::clone(<span style="color:#f92672">&amp;</span>foo);  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Rc::clone(<span style="color:#f92672">&amp;</span>foo);
</span></span></code></pre></div><p><img loading="lazy" src="/attachments/2024-07-17-rust/eb825f79-c1a7-414e-8385-2e05e467a3ad.png" alt=""  title=" =584.5x308"  />
</p>
<p>实际上通过源代码就可以窥探到Rc的内存布局，下图展示了Rc的相关源代码，其中<strong>PhantomData</strong>和<strong>alloc=Global</strong>都是0大小的类型，所以不占用内存， 因此逆向的时候，内存里实际看到的就是<strong>ptr指针及其指向的strong、weak以及value</strong>。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/e7a17665-a8b5-4808-9c09-03e2bb847794.png" alt=""  />
</p>
<p>Rc在反编译代码中很容易就可以识别出来，通过<code>Rc&lt;T&gt;</code>关键词识别。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/d7097fce-d6f2-466c-914a-ed8693c21bee.png" alt=""  />
</p>
<h1 id="五总结">五、总结<a hidden class="anchor" aria-hidden="true" href="#五总结">#</a></h1>
<p><strong>所以，是什么让Rust这么反编译可读性很差？</strong></p>
<p>正如在前言里所言，Rust 编译器的极致裁量权导致源代码与编译得到的机器码存在天壤之别，进而导致反编译算法恢复出来的伪代码与原始代码存在较大出入。在Rust各式各样的优化中，变量复用会极大的增加反编译的难度。</p>
<p>相关博客也指出了类似的问题<a href="https://showlinkroom.me/2023/04/21/PlaidCTF-baby-heap-question-mark/#more">l1nk-baby-heap-question-mark</a>、 <a href="https://rustsec.org/advisories/RUSTSEC-2023-0078.html">编译器stack rebinding引入的潜在漏洞</a>，用一个例子简单理解以下栈变量复用（stack slot reuse）。参考如下代码，main函数中同样的栈区域（由于栈重用，a与b在main函数栈的同一块区域）指向不同类型的数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>; <span style="color:#75715e">// `a` 的生命周期开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        println!(<span style="color:#e6db74">&#34;The value of a is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, a);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// `a` 的生命周期结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>; <span style="color:#75715e">// `b` 的生命周期开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        println!(<span style="color:#e6db74">&#34;The value of b is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, b);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// `b` 的生命周期结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其反编译代码如下，可以看到v2[0]一开始指向了4字节常量42，但是后面又指向了一个字符串，类型从u32变成指针，从而造成反编译困难。</p>
<p><img loading="lazy" src="/attachments/2024-07-17-rust/5a0e8d01-4a24-40c5-bdb3-218ff4e5df92.png" alt=""  />
</p>
<h2 id="六参考文档">六、参考文档<a hidden class="anchor" aria-hidden="true" href="#六参考文档">#</a></h2>
<ol>
<li><a href="https://nathanrutherford.substack.com/p/ghidra-11-rust-support">ghidra对rust的支持</a></li>
<li><a href="https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer">什么是fat pointer</a></li>
<li><strong><a href="https://segmentfault.com/a/1190000043915414">图解 Rust 内存布局</a></strong></li>
<li><a href="https://google.github.io/comprehensive-rust/zh-CN/#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0-comprehensive-rust-">欢迎来到 Comprehensive Rust</a></li>
</ol>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blog/tiangongarticle040/">
    <span class="title">« 上一页</span>
    <br>
    <span>JDBC Attack 与高版本 JDK 下的 JNDI Bypass</span>
  </a>
  <a class="next" href="http://localhost:1313/blog/tiangongarticle038/">
    <span class="title">下一页 »</span>
    <br>
    <span>Python Web 内存马多框架植入技术详解</span>
  </a>
</nav>





  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://poc.qianxin.com/home">天工实验室</a></span>
        

    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
