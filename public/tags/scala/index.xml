<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Scala on 天工实验室</title>
    <link>http://localhost:1313/tags/scala/</link>
    <description>Recent content in Scala on 天工实验室</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh</language>
    <copyright>天工实验室</copyright>
    <lastBuildDate>Wed, 07 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Scala代码审计之痛 -- Scala与Java的爱恨情仇</title>
      <link>http://localhost:1313/blog/tiangongarticle042/</link>
      <pubDate>Wed, 07 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/tiangongarticle042/</guid>
      <description>Scala代码审计之痛 &amp;ndash; Scala与Java的爱恨情仇 一、前言 Scala 是一门多范式的编程语言，集成了面向对象编程和函数式编程的多种特性。函数式编程抽象的理论基础也让这门语言变得抽象起来，初学者需要花更多的时间去理解其特有概念以及众多的语法糖。Scala是一门运行在JVM平台上的语言，其源码编译结果符合Java字节码规范，所以可以被反编译为Java代码。在进行Scala代码审计的过程中，审计者很少有机会直面其源码，大多数时候都是被反编译为Java的代码所支配。Scala与Java毕竟是两门语言，反编译成Java代码的后果便是丧失了动态调试的能力（这为审计者带来了不小的麻烦），反编译后产生的中间代码、临时变量等辅助结构更是极大得降低了代码的可读性。本文将带领诸位抽丝剥茧逐步梳理出Scala各语法结构与Java语法结构对应关系，最后以两个漏洞案例的分析加以对比说明。
二、特殊语法结构识别 除了循环、条件判断、面向对象等基础语法外，Scala还提供了极具特色的语法结构，如：模式匹配、隐式转换、传名调用、函数柯里化、伴生对象、特质、提取器、函数式编程等。本章不会重点着墨于这些语法的介绍，而是向读者展示在将Scala源程序反编译为Java代码后产生的那些不太常规的语法结构以及一些奇怪的变量（MODULE$/$outer/package/$init$）等。
2.1 伴生对象 本节将会涉及到特殊变量MODULE$的含义
Scala中没有static关键字，其通过伴生对象来实现static的效果。伴生对象是类自身定义的单个实例，可以被理解为当前类的一个单例对象（并不显式依赖一个类，可独立存在），以下代码展示了一个类的伴生对象：
package org.example class Singletons(){ private var llac: String = &amp;#34;九敏啊，我是伴生类的私有属性，我被伴生对象调用了&amp;#34; private def callSingleField(): Unit = { // 调用伴生对象的私有属性 println(Singletons.call) } } object Singletons { private var call: String = &amp;#34;九敏啊，我是伴生对象的私有属性，我被伴生类调用了&amp;#34; def sayHello(llac: String): Unit = { println(llac) } def main(args: Array[String]): Unit = { val s: Singletons = new Singletons() // 调用伴生类的私有属性 sayHello(s.llac) // 调用伴生类的私有方法 s.callSingleField() } } 在上面提供的代码中，被关键字object修饰的对象被称为类Singletons的伴生对象，类Singletons被称为object关键字修饰的对象的伴生类，两者可互相调用其私有属性以及方法。</description>
    </item>
  </channel>
</rss>
